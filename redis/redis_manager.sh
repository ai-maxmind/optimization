#!/bin/bash

###############################################################################
# Redis Manager - All-in-One Script for Ubuntu
# CÃ i Ä‘áº·t, Gá»¡ cÃ i Ä‘áº·t, vÃ  SiÃªu Tá»‘i Æ°u hÃ³a Redis
# Supports Ubuntu 20.04, 22.04, 24.04
###############################################################################

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Global variables
REDIS_VERSION="7.2.4"
REDIS_CONF="/etc/redis/redis.conf"
CPU_CORES=$(nproc)
TOTAL_RAM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}' 2>/dev/null || echo "4194304")
TOTAL_RAM_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_RAM_KB/1024/1024}")
RECOMMENDED_RAM_GB=$(awk "BEGIN {printf \"%.0f\", $TOTAL_RAM_GB * 0.65}")

###############################################################################
# UTILITY FUNCTIONS
###############################################################################

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[âœ“]${NC} $1"
}

log_section() {
    echo ""
    echo -e "${CYAN}========================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}========================================${NC}"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "Script nÃ y cáº§n cháº¡y vá»›i quyá»n root (sudo)"
        exit 1
    fi
}

detect_system() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$NAME
        VER=$VERSION_ID
    else
        log_error "KhÃ´ng thá»ƒ xÃ¡c Ä‘á»‹nh há»‡ Ä‘iá»u hÃ nh"
        exit 1
    fi
}

pause() {
    echo ""
    read -p "Nháº¥n Enter Ä‘á»ƒ tiáº¿p tá»¥c..."
}

###############################################################################
# INSTALLATION FUNCTIONS
###############################################################################

install_dependencies() {
    log_info "CÃ i Ä‘áº·t cÃ¡c gÃ³i phá»¥ thuá»™c..."
    
    apt-get update -qq
    apt-get install -y \
        build-essential \
        tcl \
        tcl-dev \
        pkg-config \
        libsystemd-dev \
        wget \
        curl \
        tar \
        systemd \
        lsb-release \
        > /dev/null 2>&1
    
    log_success "ÄÃ£ cÃ i Ä‘áº·t cÃ¡c gÃ³i phá»¥ thuá»™c"
}

install_redis_from_source() {
    log_info "CÃ i Ä‘áº·t Redis ${REDIS_VERSION} tá»« mÃ£ nguá»“n..."
    
    REDIS_URL="http://download.redis.io/releases/redis-${REDIS_VERSION}.tar.gz"
    
    cd /tmp
    wget -q "${REDIS_URL}" -O redis.tar.gz
    
    if [ $? -ne 0 ]; then
        log_error "KhÃ´ng thá»ƒ download Redis"
        exit 1
    fi
    
    tar xzf redis.tar.gz
    cd "redis-${REDIS_VERSION}"
    
    log_info "BiÃªn dá»‹ch Redis vá»›i tá»‘i Æ°u hÃ³a..."
    
    make BUILD_TLS=yes USE_SYSTEMD=yes MALLOC=jemalloc -j$(nproc) > /dev/null 2>&1
    make install > /dev/null 2>&1
    
    log_success "ÄÃ£ biÃªn dá»‹ch vÃ  cÃ i Ä‘áº·t Redis ${REDIS_VERSION}"
    
    cd /tmp
    rm -rf "redis-${REDIS_VERSION}" redis.tar.gz
}

create_redis_user() {
    log_info "Táº¡o user vÃ  group cho Redis..."
    
    if ! id -u redis > /dev/null 2>&1; then
        useradd --system --no-create-home --shell /bin/false redis
        log_success "ÄÃ£ táº¡o user redis"
    else
        log_warn "User redis Ä‘Ã£ tá»“n táº¡i"
    fi
}

setup_redis_directories() {
    log_info "Thiáº¿t láº­p thÆ° má»¥c cho Redis..."
    
    mkdir -p /etc/redis
    mkdir -p /var/lib/redis
    mkdir -p /var/log/redis
    mkdir -p /var/run/redis
    
    chown -R redis:redis /var/lib/redis
    chown -R redis:redis /var/log/redis
    chown -R redis:redis /var/run/redis
    
    chmod 750 /var/lib/redis
    chmod 750 /var/log/redis
    
    log_success "ÄÃ£ thiáº¿t láº­p thÆ° má»¥c"
}

create_redis_config() {
    log_info "Táº¡o file cáº¥u hÃ¬nh Redis siÃªu tá»‘i Æ°u..."
    
    cat > /etc/redis/redis.conf <<'EOF'
# Redis Configuration - Ultra Optimized
# Generated by Redis Manager

################################## NETWORK #####################################

bind 127.0.0.1
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300

################################# GENERAL #####################################

daemonize no
supervised systemd
pidfile /var/run/redis/redis-server.pid
loglevel notice
logfile /var/log/redis/redis-server.log
databases 16

################################ SNAPSHOTTING  ################################

save 900 1
save 300 10
save 60 10000

stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /var/lib/redis

################################# REPLICATION #################################

replica-serve-stale-data yes
replica-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
replica-priority 100

################################## SECURITY ###################################

# requirepass your_strong_password_here

################################### CLIENTS ####################################

maxclients 10000

############################## MEMORY MANAGEMENT ###############################

maxmemory 2gb
maxmemory-policy allkeys-lru
maxmemory-samples 5

############################# LAZY FREEING ####################################

lazyfree-lazy-eviction yes
lazyfree-lazy-expire yes
lazyfree-lazy-server-del yes
replica-lazy-flush yes
lazyfree-lazy-user-del yes

############################## APPEND ONLY MODE ###############################

appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
aof-use-rdb-preamble yes

################################ LUA SCRIPTING  ###############################

lua-time-limit 5000

################################## SLOW LOG ###################################

slowlog-log-slower-than 10000
slowlog-max-len 128

################################ LATENCY MONITOR ##############################

latency-monitor-threshold 100

############################# EVENT NOTIFICATION ##############################

notify-keyspace-events ""

############################### ADVANCED CONFIG ###############################

hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
stream-node-max-bytes 4096
stream-node-max-entries 100
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
dynamic-hz yes
aof-rewrite-incremental-fsync yes
rdb-save-incremental-fsync yes
EOF

    chown redis:redis /etc/redis/redis.conf
    chmod 640 /etc/redis/redis.conf
    
    log_success "ÄÃ£ táº¡o file cáº¥u hÃ¬nh"
}

create_systemd_service() {
    log_info "Táº¡o systemd service..."
    
    cat > /etc/systemd/system/redis.service <<'EOF'
[Unit]
Description=Redis In-Memory Data Store
After=network.target

[Service]
Type=notify
User=redis
Group=redis
ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf
ExecStop=/usr/local/bin/redis-cli shutdown
Restart=always
RestartSec=5s

NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/lib/redis /var/log/redis /var/run/redis

LimitNOFILE=65535
LimitNPROC=65535

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    log_success "ÄÃ£ táº¡o systemd service"
}

optimize_system() {
    log_info "Tá»‘i Æ°u hÃ³a há»‡ thá»‘ng cho Redis..."
    
    cat > /etc/sysctl.d/99-redis.conf <<'EOF'
# Redis Kernel Optimization

net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_keepalive_time = 300
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_keepalive_intvl = 30

vm.overcommit_memory = 1
vm.swappiness = 1

fs.file-max = 2097152
EOF

    sysctl -p /etc/sysctl.d/99-redis.conf > /dev/null 2>&1
    
    # Táº¯t Transparent Huge Pages
    if [ -f /sys/kernel/mm/transparent_hugepage/enabled ]; then
        echo never > /sys/kernel/mm/transparent_hugepage/enabled
        echo never > /sys/kernel/mm/transparent_hugepage/defrag
        
        cat > /etc/systemd/system/disable-thp.service <<'EOF'
[Unit]
Description=Disable Transparent Huge Pages (THP)
DefaultDependencies=no
After=sysinit.target local-fs.target
Before=redis.service

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'echo never > /sys/kernel/mm/transparent_hugepage/enabled'
ExecStart=/bin/sh -c 'echo never > /sys/kernel/mm/transparent_hugepage/defrag'

[Install]
WantedBy=basic.target
EOF
        
        systemctl daemon-reload
        systemctl enable disable-thp.service > /dev/null 2>&1
        systemctl start disable-thp.service > /dev/null 2>&1
    fi
    
    cat >> /etc/security/limits.conf <<'EOF'

# Redis limits
redis soft nofile 65535
redis hard nofile 65535
redis soft nproc 65535
redis hard nproc 65535
EOF
    
    log_success "ÄÃ£ tá»‘i Æ°u hÃ³a há»‡ thá»‘ng"
}

start_redis() {
    log_info "Khá»Ÿi Ä‘á»™ng Redis..."
    
    systemctl enable redis.service > /dev/null 2>&1
    systemctl start redis.service
    
    sleep 2
    
    if systemctl is-active --quiet redis.service; then
        log_success "Redis Ä‘ang cháº¡y thÃ nh cÃ´ng!"
    else
        log_error "KhÃ´ng thá»ƒ khá»Ÿi Ä‘á»™ng Redis"
        systemctl status redis.service
        exit 1
    fi
}

install_redis_complete() {
    log_section "CÃ€I Äáº¶T REDIS"
    
    check_root
    detect_system
    
    log_info "PhÃ¡t hiá»‡n: $OS $VER"
    log_info "CPU cores: $CPU_CORES"
    log_info "Total RAM: ${TOTAL_RAM_GB}GB"
    
    echo ""
    read -p "Báº¡n cÃ³ muá»‘n tiáº¿p tá»¥c cÃ i Ä‘áº·t Redis? (y/n): " confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        log_info "ÄÃ£ há»§y cÃ i Ä‘áº·t"
        return
    fi
    
    install_dependencies
    install_redis_from_source
    create_redis_user
    setup_redis_directories
    create_redis_config
    create_systemd_service
    optimize_system
    start_redis
    
    log_section "CÃ€I Äáº¶T HOÃ€N Táº¤T"
    
    echo ""
    log_success "Redis Ä‘Ã£ Ä‘Æ°á»£c cÃ i Ä‘áº·t thÃ nh cÃ´ng!"
    echo ""
    echo "ThÃ´ng tin:"
    echo "  - File cáº¥u hÃ¬nh: /etc/redis/redis.conf"
    echo "  - ThÆ° má»¥c dá»¯ liá»‡u: /var/lib/redis"
    echo "  - Log file: /var/log/redis/redis-server.log"
    echo ""
    echo "CÃ¡c lá»‡nh há»¯u Ã­ch:"
    echo "  - Kiá»ƒm tra tráº¡ng thÃ¡i: sudo systemctl status redis"
    echo "  - Káº¿t ná»‘i: redis-cli"
    echo "  - Test: redis-cli ping"
    echo ""
    log_warn "LÆ¯U Ã: NÃªn Ä‘áº·t password trong /etc/redis/redis.conf"
    
    pause
}

###############################################################################
# UNINSTALLATION FUNCTIONS
###############################################################################

confirm_uninstall() {
    log_section "Gá»  CÃ€I Äáº¶T REDIS"
    
    echo ""
    log_warn "Cáº¢NH BÃO: Script nÃ y sáº½ XÃ“A HOÃ€N TOÃ€N Redis vÃ  Táº¤T Cáº¢ Dá»® LIá»†U!"
    log_warn "Bao gá»“m:"
    echo "  - Redis binaries"
    echo "  - Dá»¯ liá»‡u trong /var/lib/redis"
    echo "  - File cáº¥u hÃ¬nh"
    echo "  - Log files"
    echo "  - Systemd service"
    echo ""
    
    read -p "Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n tiáº¿p tá»¥c? (yes/no): " response
    
    if [[ "$response" != "yes" ]]; then
        log_info "ÄÃ£ há»§y gá»¡ cÃ i Ä‘áº·t"
        return 1
    fi
    
    echo ""
    log_warn "Láº§n xÃ¡c nháº­n cuá»‘i cÃ¹ng!"
    read -p "GÃµ 'DELETE' Ä‘á»ƒ xÃ¡c nháº­n xÃ³a hoÃ n toÃ n Redis: " final_confirm
    
    if [[ "$final_confirm" != "DELETE" ]]; then
        log_info "ÄÃ£ há»§y gá»¡ cÃ i Ä‘áº·t"
        return 1
    fi
    
    return 0
}

backup_data() {
    echo ""
    read -p "Báº¡n cÃ³ muá»‘n backup dá»¯ liá»‡u trÆ°á»›c khi xÃ³a? (y/n): " backup_choice
    
    if [[ "$backup_choice" == "y" || "$backup_choice" == "Y" ]]; then
        BACKUP_DIR="/tmp/redis_backup_$(date +%Y%m%d_%H%M%S)"
        mkdir -p "$BACKUP_DIR"
        
        if [ -d /var/lib/redis ]; then
            cp -r /var/lib/redis "$BACKUP_DIR/" 2>/dev/null || true
        fi
        
        if [ -f /etc/redis/redis.conf ]; then
            cp /etc/redis/redis.conf "$BACKUP_DIR/" 2>/dev/null || true
        fi
        
        log_success "Backup Ä‘Æ°á»£c lÆ°u táº¡i: $BACKUP_DIR"
        echo ""
    fi
}

stop_redis() {
    log_info "Dá»«ng Redis service..."
    
    if systemctl is-active --quiet redis.service 2>/dev/null; then
        systemctl stop redis.service
        log_success "ÄÃ£ dá»«ng Redis service"
    else
        log_warn "Redis service khÃ´ng cháº¡y"
    fi
    
    if systemctl is-enabled --quiet redis.service 2>/dev/null; then
        systemctl disable redis.service > /dev/null 2>&1
        log_success "ÄÃ£ disable Redis service"
    fi
}

remove_systemd_service() {
    log_info "XÃ³a systemd services..."
    
    if [ -f /etc/systemd/system/redis.service ]; then
        rm -f /etc/systemd/system/redis.service
        log_success "ÄÃ£ xÃ³a redis.service"
    fi
    
    if [ -f /etc/systemd/system/disable-thp.service ]; then
        systemctl stop disable-thp.service 2>/dev/null || true
        systemctl disable disable-thp.service 2>/dev/null || true
        rm -f /etc/systemd/system/disable-thp.service
        log_success "ÄÃ£ xÃ³a disable-thp.service"
    fi
    
    systemctl daemon-reload
}

remove_binaries() {
    log_info "XÃ³a Redis binaries..."
    
    BINARIES=(
        "/usr/local/bin/redis-server"
        "/usr/local/bin/redis-cli"
        "/usr/local/bin/redis-benchmark"
        "/usr/local/bin/redis-check-aof"
        "/usr/local/bin/redis-check-rdb"
        "/usr/local/bin/redis-sentinel"
    )
    
    for binary in "${BINARIES[@]}"; do
        if [ -f "$binary" ]; then
            rm -f "$binary"
        fi
    done
    
    log_success "ÄÃ£ xÃ³a Redis binaries"
}

remove_directories() {
    log_info "XÃ³a thÆ° má»¥c Redis..."
    
    DIRECTORIES=(
        "/etc/redis"
        "/var/lib/redis"
        "/var/log/redis"
        "/var/run/redis"
    )
    
    for dir in "${DIRECTORIES[@]}"; do
        if [ -d "$dir" ]; then
            rm -rf "$dir"
        fi
    done
    
    log_success "ÄÃ£ xÃ³a thÆ° má»¥c Redis"
}

remove_user() {
    log_info "XÃ³a user Redis..."
    
    if id -u redis > /dev/null 2>&1; then
        userdel redis 2>/dev/null || true
        log_success "ÄÃ£ xÃ³a user redis"
    fi
}

remove_optimizations() {
    log_info "XÃ³a kernel optimizations..."
    
    if [ -f /etc/sysctl.d/99-redis.conf ]; then
        rm -f /etc/sysctl.d/99-redis.conf
        sysctl --system > /dev/null 2>&1
    fi
    
    if [ -f /etc/sysctl.d/99-redis-advanced.conf ]; then
        rm -f /etc/sysctl.d/99-redis-advanced.conf
        sysctl --system > /dev/null 2>&1
    fi
    
    if [ -f /sys/kernel/mm/transparent_hugepage/enabled ]; then
        echo always > /sys/kernel/mm/transparent_hugepage/enabled 2>/dev/null || true
        echo always > /sys/kernel/mm/transparent_hugepage/defrag 2>/dev/null || true
    fi
    
    if [ -f /etc/security/limits.conf ]; then
        sed -i '/# Redis limits/,/^$/d' /etc/security/limits.conf 2>/dev/null || true
    fi
    
    log_success "ÄÃ£ xÃ³a optimizations"
}

remove_maintenance_scripts() {
    log_info "XÃ³a maintenance scripts..."
    
    SCRIPTS=(
        "/usr/local/bin/redis-monitor.sh"
        "/usr/local/bin/redis-benchmark-test.sh"
        "/usr/local/bin/redis-backup.sh"
        "/usr/local/bin/redis-clean.sh"
    )
    
    for script in "${SCRIPTS[@]}"; do
        if [ -f "$script" ]; then
            rm -f "$script"
        fi
    done
    
    if [ -f /etc/systemd/system/redis.service.d/override.conf ]; then
        rm -rf /etc/systemd/system/redis.service.d
        systemctl daemon-reload
    fi
    
    log_success "ÄÃ£ xÃ³a maintenance scripts"
}

uninstall_redis_complete() {
    check_root
    
    if ! confirm_uninstall; then
        return
    fi
    
    backup_data
    stop_redis
    remove_systemd_service
    remove_binaries
    remove_directories
    remove_user
    remove_optimizations
    remove_maintenance_scripts
    
    log_section "Gá»  CÃ€I Äáº¶T HOÃ€N Táº¤T"
    
    echo ""
    log_success "ÄÃ£ gá»¡ cÃ i Ä‘áº·t Redis hoÃ n toÃ n!"
    echo ""
    
    if [ -d "$BACKUP_DIR" ]; then
        log_info "Backup cá»§a báº¡n: $BACKUP_DIR"
        log_warn "Nhá»› xÃ³a backup náº¿u khÃ´ng cáº§n: rm -rf $BACKUP_DIR"
    fi
    
    pause
}

###############################################################################
# OPTIMIZATION FUNCTIONS
###############################################################################

check_redis_installed() {
    if ! command -v redis-cli &> /dev/null; then
        log_error "Redis chÆ°a Ä‘Æ°á»£c cÃ i Ä‘áº·t!"
        log_info "Chá»n menu 1 Ä‘á»ƒ cÃ i Ä‘áº·t Redis trÆ°á»›c"
        pause
        return 1
    fi
    
    if ! systemctl is-active --quiet redis.service; then
        log_error "Redis service khÃ´ng cháº¡y!"
        log_info "Khá»Ÿi Ä‘á»™ng báº±ng: sudo systemctl start redis"
        pause
        return 1
    fi
    
    return 0
}

detect_system_resources() {
    log_info "Äang phÃ¡t hiá»‡n tÃ i nguyÃªn há»‡ thá»‘ng..."
    
    CPU_CORES=$(nproc)
    TOTAL_RAM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    TOTAL_RAM_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_RAM_KB/1024/1024}")
    RECOMMENDED_RAM_GB=$(awk "BEGIN {printf \"%.0f\", $TOTAL_RAM_GB * 0.65}")
    
    DISK_TYPE="unknown"
    if lsblk -d -o name,rota 2>/dev/null | grep -q "0"; then
        DISK_TYPE="SSD"
    else
        DISK_TYPE="HDD"
    fi
    
    echo ""
    log_success "TÃ i nguyÃªn há»‡ thá»‘ng:"
    echo "  - CPU cores: $CPU_CORES"
    echo "  - Tá»•ng RAM: ${TOTAL_RAM_GB}GB"
    echo "  - RAM khuyáº¿n nghá»‹ cho Redis: ${RECOMMENDED_RAM_GB}GB"
    echo "  - Loáº¡i disk: $DISK_TYPE"
}

optimize_redis_config() {
    log_info "Tá»‘i Æ°u hÃ³a cáº¥u hÃ¬nh Redis..."
    
    if [ ! -f "$REDIS_CONF" ]; then
        log_error "KhÃ´ng tÃ¬m tháº¥y file cáº¥u hÃ¬nh: $REDIS_CONF"
        return 1
    fi
    
    cp "$REDIS_CONF" "${REDIS_CONF}.backup.$(date +%Y%m%d_%H%M%S)"
    log_info "ÄÃ£ backup cáº¥u hÃ¬nh hiá»‡n táº¡i"
    
    # Update maxmemory
    if grep -q "^maxmemory" "$REDIS_CONF"; then
        sed -i "s/^maxmemory .*/maxmemory ${RECOMMENDED_RAM_GB}gb/" "$REDIS_CONF"
    else
        echo "maxmemory ${RECOMMENDED_RAM_GB}gb" >> "$REDIS_CONF"
    fi
    
    # Enable IO threads
    if [ "$CPU_CORES" -ge 4 ]; then
        IO_THREADS=$((CPU_CORES / 2))
        if [ "$IO_THREADS" -gt 8 ]; then
            IO_THREADS=8
        fi
        
        if grep -q "^# io-threads" "$REDIS_CONF"; then
            sed -i "s/^# io-threads .*/io-threads $IO_THREADS/" "$REDIS_CONF"
            sed -i "s/^# io-threads-do-reads .*/io-threads-do-reads yes/" "$REDIS_CONF"
        else
            cat >> "$REDIS_CONF" <<EOF

# IO Threads
io-threads $IO_THREADS
io-threads-do-reads yes
EOF
        fi
    fi
    
    # Add advanced optimizations
    cat >> "$REDIS_CONF" <<'EOF'

# Advanced Optimizations - Generated by Redis Manager

activedefrag yes
active-defrag-ignore-bytes 100mb
active-defrag-threshold-lower 10
active-defrag-threshold-upper 25
active-defrag-cycle-min 5
active-defrag-cycle-max 75

jemalloc-bg-thread yes

repl-backlog-size 512mb
repl-backlog-ttl 3600

client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 512mb 128mb 60
client-output-buffer-limit pubsub 64mb 16mb 60

proto-max-bulk-len 512mb
EOF

    log_success "ÄÃ£ tá»‘i Æ°u cáº¥u hÃ¬nh Redis"
}

optimize_kernel_advanced() {
    log_info "Tá»‘i Æ°u hÃ³a kernel nÃ¢ng cao..."
    
    cat > /etc/sysctl.d/99-redis-advanced.conf <<EOF
# Redis Advanced Kernel Optimization

net.core.somaxconn = 65535
net.core.netdev_max_backlog = 65535
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_fin_timeout = 15
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_keepalive_time = 300
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.ip_local_port_range = 10000 65535

vm.overcommit_memory = 1
vm.swappiness = 0
vm.vfs_cache_pressure = 50
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5

fs.file-max = 2097152
fs.nr_open = 2097152
EOF

    sysctl -p /etc/sysctl.d/99-redis-advanced.conf > /dev/null 2>&1
    
    log_success "ÄÃ£ Ã¡p dá»¥ng kernel optimizations"
}

optimize_systemd_service() {
    log_info "Tá»‘i Æ°u hÃ³a systemd service..."
    
    mkdir -p /etc/systemd/system/redis.service.d
    
    cat > /etc/systemd/system/redis.service.d/override.conf <<EOF
[Service]
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
Nice=-5
OOMScoreAdjust=-900
RestartSec=3s
StartLimitInterval=0
EOF

    systemctl daemon-reload
    
    log_success "ÄÃ£ tá»‘i Æ°u systemd service"
}

setup_monitoring() {
    log_info "Thiáº¿t láº­p monitoring scripts..."
    
    cat > /usr/local/bin/redis-monitor.sh <<'EOF'
#!/bin/bash

echo "=========================================="
echo "Redis Performance Monitor"
echo "Time: $(date)"
echo "=========================================="
echo ""

if ! systemctl is-active --quiet redis.service; then
    echo "ERROR: Redis is not running!"
    exit 1
fi

redis-cli INFO | grep -E "used_memory_human|used_memory_peak_human|instantaneous_ops_per_sec|connected_clients|blocked_clients|evicted_keys|keyspace_hits|keyspace_misses"

echo ""
echo "Cache Hit Rate:"
HITS=$(redis-cli INFO stats | grep keyspace_hits | cut -d: -f2 | tr -d '\r')
MISSES=$(redis-cli INFO stats | grep keyspace_misses | cut -d: -f2 | tr -d '\r')
if [ "$HITS" -gt 0 ] || [ "$MISSES" -gt 0 ]; then
    TOTAL=$((HITS + MISSES))
    HIT_RATE=$(awk "BEGIN {printf \"%.2f\", ($HITS / $TOTAL) * 100}")
    echo "  Hit rate: ${HIT_RATE}%"
else
    echo "  No data yet"
fi

echo ""
echo "=========================================="
EOF

    chmod +x /usr/local/bin/redis-monitor.sh
    
    cat > /usr/local/bin/redis-backup.sh <<'EOF'
#!/bin/bash

BACKUP_DIR="/var/backups/redis"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

echo "Creating Redis backup..."
redis-cli BGSAVE
sleep 2

cp /var/lib/redis/dump.rdb "$BACKUP_DIR/dump_${DATE}.rdb" 2>/dev/null
cp /var/lib/redis/appendonly.aof "$BACKUP_DIR/appendonly_${DATE}.aof" 2>/dev/null || true

echo "Backup completed: $BACKUP_DIR/dump_${DATE}.rdb"

find "$BACKUP_DIR" -name "dump_*.rdb" -mtime +7 -delete
find "$BACKUP_DIR" -name "appendonly_*.aof" -mtime +7 -delete
EOF

    chmod +x /usr/local/bin/redis-backup.sh
    
    log_success "ÄÃ£ táº¡o monitoring scripts"
}

restart_redis() {
    log_info "Äang khá»Ÿi Ä‘á»™ng láº¡i Redis..."
    
    systemctl restart redis.service
    sleep 2
    
    if systemctl is-active --quiet redis.service; then
        log_success "Redis Ä‘Ã£ khá»Ÿi Ä‘á»™ng láº¡i thÃ nh cÃ´ng!"
    else
        log_error "Lá»—i khi khá»Ÿi Ä‘á»™ng láº¡i Redis!"
        systemctl status redis.service
        pause
        return 1
    fi
}

detect_numa_topology() {
    log_info "PhÃ¡t hiá»‡n NUMA topology..."
    
    if command -v numactl &> /dev/null; then
        NUMA_NODES=$(numactl --hardware | grep "available:" | awk '{print $2}')
        NUMA_ENABLED="yes"
        log_success "NUMA nodes: $NUMA_NODES"
        
        # Get NUMA memory info
        NUMA_MEM_NODE0=$(numactl --hardware | grep "node 0 size" | awk '{print $4}')
        log_info "NUMA Node 0 Memory: ${NUMA_MEM_NODE0}MB"
    else
        NUMA_NODES=1
        NUMA_ENABLED="no"
        log_warn "NUMA khÃ´ng kháº£ dá»¥ng hoáº·c chÆ°a cÃ i numactl"
    fi
    
    # Check CPU governor
    if [ -f /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor ]; then
        CPU_GOVERNOR=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor)
        log_info "CPU Governor: $CPU_GOVERNOR"
    fi
    
    # Check CPU topology
    CPU_SOCKETS=$(lscpu | grep "Socket(s):" | awk '{print $2}')
    CORES_PER_SOCKET=$(lscpu | grep "Core(s) per socket:" | awk '{print $4}')
    THREADS_PER_CORE=$(lscpu | grep "Thread(s) per core:" | awk '{print $4}')
    
    # Detect CPU cache
    L1_CACHE=$(lscpu | grep "L1d cache:" | awk '{print $3}')
    L2_CACHE=$(lscpu | grep "L2 cache:" | awk '{print $3}')
    L3_CACHE=$(lscpu | grep "L3 cache:" | awk '{print $3}')
    
    log_info "CPU Topology: ${CPU_SOCKETS}x sockets, ${CORES_PER_SOCKET} cores/socket, ${THREADS_PER_CORE} threads/core"
    log_info "CPU Cache: L1=${L1_CACHE}, L2=${L2_CACHE}, L3=${L3_CACHE}"
    
    # Detect CPU architecture
    CPU_ARCH=$(uname -m)
    CPU_MODEL=$(lscpu | grep "Model name:" | cut -d: -f2 | xargs)
    log_info "CPU: $CPU_MODEL ($CPU_ARCH)"
}

detect_memory_bandwidth() {
    log_info "PhÃ¢n tÃ­ch memory bandwidth..."
    
    # Check if we can measure memory bandwidth
    if command -v mbw &> /dev/null; then
        log_info "Äang Ä‘o memory bandwidth (cÃ³ thá»ƒ máº¥t vÃ i giÃ¢y)..."
        MEM_BANDWIDTH=$(mbw -q 100 2>&1 | tail -1 | awk '{print $2}')
        log_success "Memory Bandwidth: ~${MEM_BANDWIDTH} MB/s"
    else
        log_warn "mbw chÆ°a cÃ i - bá» qua bandwidth test"
    fi
    
    # Check memory type
    if command -v dmidecode &> /dev/null; then
        MEM_TYPE=$(dmidecode -t memory 2>/dev/null | grep "Type:" | grep -v "Error" | head -1 | awk '{print $2}')
        MEM_SPEED=$(dmidecode -t memory 2>/dev/null | grep "Speed:" | grep -v "Unknown" | head -1 | awk '{print $2, $3}')
        log_info "Memory: $MEM_TYPE @ $MEM_SPEED"
    fi
}

detect_network_hardware() {
    log_info "PhÃ¢n tÃ­ch network hardware..."
    
    # Get network interface info
    PRIMARY_NIC=$(ip route | grep default | awk '{print $5}' | head -1)
    if [ ! -z "$PRIMARY_NIC" ]; then
        NIC_SPEED=$(ethtool "$PRIMARY_NIC" 2>/dev/null | grep "Speed:" | awk '{print $2}')
        NIC_DRIVER=$(ethtool -i "$PRIMARY_NIC" 2>/dev/null | grep "driver:" | awk '{print $2}')
        
        log_info "Primary NIC: $PRIMARY_NIC"
        log_info "NIC Speed: $NIC_SPEED"
        log_info "NIC Driver: $NIC_DRIVER"
        
        # Check if it's a high-performance NIC
        if [[ "$NIC_DRIVER" =~ (mlx|ixgbe|i40e) ]]; then
            HIGH_PERF_NIC="yes"
            log_success "High-performance NIC detected!"
        else
            HIGH_PERF_NIC="no"
        fi
    fi
}

detect_storage_hardware() {
    log_info "PhÃ¢n tÃ­ch storage hardware chi tiáº¿t..."
    
    # Detect all storage devices
    for disk in $(lsblk -d -n -o NAME | grep -E "^sd|^nvme"); do
        DISK_PATH="/dev/$disk"
        
        # Check if it's SSD or HDD
        if [ -f "/sys/block/$disk/queue/rotational" ]; then
            ROT=$(cat "/sys/block/$disk/queue/rotational")
            if [ "$ROT" -eq 0 ]; then
                DISK_TYPES[$disk]="SSD"
            else
                DISK_TYPES[$disk]="HDD"
            fi
        fi
        
        # Get disk model
        DISK_MODEL=$(lsblk -d -n -o MODEL "$DISK_PATH" 2>/dev/null | xargs)
        
        # Get disk size
        DISK_SIZE=$(lsblk -d -n -o SIZE "$DISK_PATH" 2>/dev/null)
        
        log_info "Disk $disk: ${DISK_TYPES[$disk]} - $DISK_MODEL ($DISK_SIZE)"
        
        # Check if NVMe
        if [[ "$disk" =~ ^nvme ]]; then
            NVME_DEVICE="yes"
            # Get NVMe specific info
            if command -v nvme &> /dev/null; then
                NVME_MODEL=$(nvme id-ctrl "$DISK_PATH" 2>/dev/null | grep "^mn" | cut -d: -f2 | xargs)
                log_info "  NVMe Model: $NVME_MODEL"
            fi
        fi
    done
}

install_performance_tools() {
    log_info "CÃ i Ä‘áº·t advanced performance tools..."
    
    # Core performance tools
    apt-get install -y \
        numactl \
        numad \
        irqbalance \
        cpufrequtils \
        linux-tools-common \
        linux-tools-generic \
        sysstat \
        dstat \
        iotop \
        htop \
        atop \
        nicstat \
        > /dev/null 2>&1 || log_warn "Má»™t sá»‘ tools khÃ´ng cÃ i Ä‘Æ°á»£c"
    
    # Network performance tools
    apt-get install -y \
        ethtool \
        net-tools \
        iperf3 \
        netperf \
        tcpdump \
        socat \
        > /dev/null 2>&1 || true
    
    # Storage performance tools
    apt-get install -y \
        fio \
        ioping \
        nvme-cli \
        hdparm \
        smartmontools \
        > /dev/null 2>&1 || true
    
    # Memory tools
    apt-get install -y \
        mbw \
        dmidecode \
        > /dev/null 2>&1 || true
    
    # Tracing and profiling tools
    apt-get install -y \
        strace \
        ltrace \
        gdb \
        valgrind \
        > /dev/null 2>&1 || true
    
    # eBPF tools (if available)
    apt-get install -y \
        bpfcc-tools \
        bpftrace \
        linux-headers-$(uname -r) \
        > /dev/null 2>&1 || log_warn "eBPF tools khÃ´ng kháº£ dá»¥ng"
    
    log_success "ÄÃ£ cÃ i Ä‘áº·t performance tools"
}

optimize_transparent_hugepages() {
    log_info "Cáº¥u hÃ¬nh Transparent Huge Pages (THP) chi tiáº¿t..."
    
    # Completely disable THP for Redis (recommended)
    if [ -f /sys/kernel/mm/transparent_hugepage/enabled ]; then
        echo never > /sys/kernel/mm/transparent_hugepage/enabled
        echo never > /sys/kernel/mm/transparent_hugepage/defrag
        echo 0 > /sys/kernel/mm/transparent_hugepage/khugepaged/defrag
        
        # Disable khugepaged
        if [ -f /sys/kernel/mm/transparent_hugepage/khugepaged/scan_sleep_millisecs ]; then
            echo 60000 > /sys/kernel/mm/transparent_hugepage/khugepaged/scan_sleep_millisecs
        fi
        
        log_success "THP completely disabled for Redis"
    fi
}

configure_hugepages() {
    log_info "Cáº¥u hÃ¬nh Explicit Huge Pages..."
    
    # Calculate number of huge pages needed (2MB pages)
    # Reserve about 10% of RAM for huge pages
    HUGEPAGE_SIZE=2048  # 2MB in KB
    TOTAL_RAM_KB=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    HUGEPAGES_NEEDED=$((TOTAL_RAM_KB / HUGEPAGE_SIZE / 10))
    
    if [ "$HUGEPAGES_NEEDED" -lt 128 ]; then
        HUGEPAGES_NEEDED=128
    fi
    
    # Set huge pages
    echo $HUGEPAGES_NEEDED > /proc/sys/vm/nr_hugepages
    
    # Verify
    HUGEPAGES_SET=$(cat /proc/sys/vm/nr_hugepages)
    
    if [ "$HUGEPAGES_SET" -ge "$HUGEPAGES_NEEDED" ]; then
        log_success "Configured $HUGEPAGES_SET huge pages (${HUGEPAGES_NEEDED} requested)"
    else
        log_warn "Only $HUGEPAGES_SET huge pages available (${HUGEPAGES_NEEDED} requested)"
    fi
    
    # Make persistent
    if ! grep -q "vm.nr_hugepages" /etc/sysctl.d/99-redis-hardcore.conf 2>/dev/null; then
        echo "vm.nr_hugepages = $HUGEPAGES_NEEDED" >> /etc/sysctl.d/99-redis-hardcore.conf
    fi
}

optimize_cpu_governor() {
    log_info "Tá»‘i Æ°u CPU governor vÃ  frequency scaling..."
    
    # Set performance governor for maximum performance
    if command -v cpufreq-set &> /dev/null; then
        for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
            echo performance > "$cpu" 2>/dev/null || true
        done
        log_success "Äáº·t CPU governor sang 'performance'"
    fi
    
    # Disable CPU idle states for lowest latency
    for state in /sys/devices/system/cpu/cpu*/cpuidle/state*/disable; do
        echo 1 > "$state" 2>/dev/null || true
    done
    
    # Create systemd service to persist
    cat > /etc/systemd/system/cpu-performance.service <<'EOF'
[Unit]
Description=CPU Performance Optimization
After=multi-user.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do echo performance > $cpu 2>/dev/null || true; done'
ExecStart=/bin/bash -c 'for state in /sys/devices/system/cpu/cpu*/cpuidle/state*/disable; do echo 1 > $state 2>/dev/null || true; done'
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl daemon-reload
    systemctl enable cpu-performance.service > /dev/null 2>&1
    systemctl start cpu-performance.service > /dev/null 2>&1
    
    log_success "ÄÃ£ tá»‘i Æ°u CPU governor"
}

optimize_numa_settings() {
    log_info "Tá»‘i Æ°u NUMA settings..."
    
    if [ "$NUMA_ENABLED" = "yes" ] && [ "$NUMA_NODES" -gt 1 ]; then
        # Enable automatic NUMA balancing
        echo 1 > /proc/sys/kernel/numa_balancing 2>/dev/null || true
        
        # Start numad for automatic NUMA optimization
        if command -v numad &> /dev/null; then
            systemctl enable numad > /dev/null 2>&1
            systemctl start numad > /dev/null 2>&1
            log_success "ÄÃ£ báº­t numad daemon"
        fi
        
        cat >> /etc/sysctl.d/99-redis-advanced.conf <<EOF

# NUMA Optimizations
kernel.numa_balancing = 1
kernel.numa_balancing_scan_delay_ms = 1000
kernel.numa_balancing_scan_period_min_ms = 1000
kernel.numa_balancing_scan_period_max_ms = 60000
kernel.numa_balancing_scan_size_mb = 256
EOF
        
        sysctl -p /etc/sysctl.d/99-redis-advanced.conf > /dev/null 2>&1
        log_success "ÄÃ£ cáº¥u hÃ¬nh NUMA balancing"
    else
        log_info "Single NUMA node - bá» qua NUMA optimizations"
    fi
}

optimize_irq_affinity() {
    log_info "Tá»‘i Æ°u IRQ affinity vÃ  interrupt handling nÃ¢ng cao..."
    
    # Configure irqbalance with banned CPUs (reserve CPUs for Redis)
    if [ "$CPU_CORES" -gt 4 ]; then
        # Ban first 2 CPUs from IRQ handling (reserve for Redis)
        BANNED_CPUS="0,1"
        
        cat > /etc/default/irqbalance <<EOF
# IRQ Balance Configuration for Redis
IRQBALANCE_BANNED_CPUS=$BANNED_CPUS
IRQBALANCE_ARGS="--policyscript=/usr/local/bin/irqbalance-policy.sh"
EOF
        
        # Create policy script
        cat > /usr/local/bin/irqbalance-policy.sh <<'EOF'
#!/bin/bash
# IRQ Balance policy for Redis optimization
case "$1" in
    eth*|ens*|enp*)
        # Network IRQs - spread across non-banned CPUs
        echo "spread"
        ;;
    *)
        # Other IRQs - let irqbalance decide
        echo "spread"
        ;;
esac
EOF
        chmod +x /usr/local/bin/irqbalance-policy.sh
        
        log_info "IRQ affinity: Banned CPUs $BANNED_CPUS for IRQ (reserved for Redis)"
    fi
    
    # Start irqbalance
    systemctl enable irqbalance > /dev/null 2>&1
    systemctl restart irqbalance > /dev/null 2>&1
    
    # Optimize specific network interrupts
    if [ ! -z "$PRIMARY_NIC" ]; then
        # Get IRQs for primary NIC
        NIC_IRQS=$(grep "$PRIMARY_NIC" /proc/interrupts | cut -d: -f1 | tr -d ' ')
        
        for irq in $NIC_IRQS; do
            # Set IRQ affinity to all non-banned CPUs
            if [ "$CPU_CORES" -gt 4 ]; then
                # Use CPUs 2 onwards
                printf "%x" $(( (1 << CPU_CORES) - 1 - 3 )) > /proc/irq/$irq/smp_affinity 2>/dev/null || true
            else
                # Use all CPUs
                printf "%x" $(( (1 << CPU_CORES) - 1 )) > /proc/irq/$irq/smp_affinity 2>/dev/null || true
            fi
        done
        
        log_info "Optimized IRQs for NIC: $PRIMARY_NIC"
    fi
    
    # Disable IRQ coalescing for lowest latency (if high-perf NIC)
    if [ "$HIGH_PERF_NIC" = "yes" ] && [ ! -z "$PRIMARY_NIC" ]; then
        ethtool -C "$PRIMARY_NIC" rx-usecs 0 tx-usecs 0 2>/dev/null || log_warn "Cannot disable IRQ coalescing"
        log_info "Disabled IRQ coalescing for minimum latency"
    fi
    
    log_success "ÄÃ£ tá»‘i Æ°u IRQ affinity vÃ  interrupt handling"
}

optimize_network_card_rss() {
    log_info "Tá»‘i Æ°u Network Card RSS/RPS/RFS..."
    
    if [ -z "$PRIMARY_NIC" ]; then
        log_warn "No primary NIC found"
        return
    fi
    
    # Enable RSS (Receive Side Scaling) - hardware level
    if [ -d "/sys/class/net/$PRIMARY_NIC/queues" ]; then
        NUM_RX_QUEUES=$(ls -d /sys/class/net/$PRIMARY_NIC/queues/rx-* 2>/dev/null | wc -l)
        NUM_TX_QUEUES=$(ls -d /sys/class/net/$PRIMARY_NIC/queues/tx-* 2>/dev/null | wc -l)
        
        log_info "NIC Queues: RX=$NUM_RX_QUEUES, TX=$NUM_TX_QUEUES"
        
        # Try to increase queue count
        ethtool -L "$PRIMARY_NIC" combined $CPU_CORES 2>/dev/null || log_warn "Cannot set combined queues"
    fi
    
    # Enable RPS (Receive Packet Steering) - software level
    for rxq in /sys/class/net/$PRIMARY_NIC/queues/rx-*/rps_cpus; do
        if [ -f "$rxq" ]; then
            # Use all CPUs for RPS
            printf "%x" $(( (1 << CPU_CORES) - 1 )) > "$rxq"
        fi
    done
    
    # Enable RFS (Receive Flow Steering)
    echo 32768 > /proc/sys/net/core/rps_sock_flow_entries
    for rxq in /sys/class/net/$PRIMARY_NIC/queues/rx-*/rps_flow_cnt; do
        if [ -f "$rxq" ]; then
            echo 2048 > "$rxq"
        fi
    done
    
    # Enable XPS (Transmit Packet Steering)
    for i in $(seq 0 $((NUM_TX_QUEUES - 1))); do
        XPS_FILE="/sys/class/net/$PRIMARY_NIC/queues/tx-$i/xps_cpus"
        if [ -f "$XPS_FILE" ]; then
            # Map each TX queue to a specific CPU
            printf "%x" $((1 << i)) > "$XPS_FILE"
        fi
    done
    
    # Increase ring buffer sizes
    ethtool -G "$PRIMARY_NIC" rx 4096 tx 4096 2>/dev/null || log_warn "Cannot increase ring buffers"
    
    # Enable hardware offloads
    ethtool -K "$PRIMARY_NIC" gro on gso on tso on 2>/dev/null || true
    
    log_success "ÄÃ£ tá»‘i Æ°u Network Card RSS/RPS/RFS/XPS"
}

optimize_cpu_isolation() {
    log_info "Cáº¥u hÃ¬nh CPU Isolation cho Redis..."
    
    if [ "$CPU_CORES" -le 4 ]; then
        log_warn "KhÃ´ng Ä‘á»§ CPU cores Ä‘á»ƒ isolation (cáº§n > 4 cores)"
        return
    fi
    
    # Isolate CPUs 0-1 for Redis, leave others for OS
    ISOLATED_CPUS="0,1"
    
    # Check if kernel supports isolation
    if grep -q "isolcpus" /proc/cmdline 2>/dev/null; then
        log_info "CPU isolation already configured in kernel"
    else
        log_warn "CPU isolation cáº§n cáº¥u hÃ¬nh trong GRUB (isolcpus=$ISOLATED_CPUS)"
        log_warn "ThÃªm 'isolcpus=$ISOLATED_CPUS' vÃ o GRUB_CMDLINE_LINUX trong /etc/default/grub"
        log_warn "Sau Ä‘Ã³ cháº¡y: update-grub && reboot"
    fi
    
    # Use cgroups for CPU isolation
    if [ -d /sys/fs/cgroup/cpuset ]; then
        # Create Redis cpuset
        mkdir -p /sys/fs/cgroup/cpuset/redis
        
        # Assign CPUs 0-1 to Redis
        echo "0,1" > /sys/fs/cgroup/cpuset/redis/cpuset.cpus
        echo "0" > /sys/fs/cgroup/cpuset/redis/cpuset.mems
        echo "1" > /sys/fs/cgroup/cpuset/redis/cpuset.cpu_exclusive
        
        log_success "Created cgroup cpuset for Redis isolation"
    fi
}

optimize_memory_allocator() {
    log_info "Tá»‘i Æ°u jemalloc memory allocator hardcore..."
    
    # Calculate optimal arenas based on CPU cores
    JEMALLOC_ARENAS=$((CPU_CORES < 8 ? CPU_CORES : 8))
    
    # Create jemalloc configuration
    cat > /etc/redis/jemalloc.conf <<EOF
# Jemalloc Configuration for Redis - Hardcore Mode
# Optimized for ultra-low latency and maximum throughput

# Enable background threads for asynchronous operations
background_thread:true

# Optimize for multi-threaded workloads
narenas:$JEMALLOC_ARENAS

# Aggressive memory decay for low fragmentation
dirty_decay_ms:1000
muzzy_decay_ms:1000

# Optimize large allocations
lg_extent_max_active_fit:6

# Metadata THP
metadata_thp:auto

# Retain for performance
retain:true

# Profiling (disable in production)
prof:false
prof_active:false
prof_leak:false

# Optimize tcache
tcache:true

# Abort on error
abort:true
abort_conf:true
EOF
    
    # Set jemalloc environment variables with advanced tuning
    cat > /etc/default/redis-jemalloc <<EOF
# Jemalloc environment variables for Redis - Hardcore
export MALLOC_CONF="background_thread:true,metadata_thp:auto,dirty_decay_ms:1000,muzzy_decay_ms:1000,narenas:$JEMALLOC_ARENAS,abort:true,tcache:true,lg_tcache_max:15,retain:true"
export JEMALLOC_PROF_LEAK=0
EOF
    
    log_success "ÄÃ£ cáº¥u hÃ¬nh jemalloc vá»›i $JEMALLOC_ARENAS arenas"
}

optimize_memory_locking() {
    log_info "Cáº¥u hÃ¬nh memory locking (mlockall)..."
    
    # Enable memory locking in systemd
    mkdir -p /etc/systemd/system/redis.service.d
    
    if ! grep -q "LimitMEMLOCK" /etc/systemd/system/redis.service.d/override.conf 2>/dev/null; then
        cat >> /etc/systemd/system/redis.service.d/override.conf <<EOF

# Memory Locking
LimitMEMLOCK=infinity
EOF
    fi
    
    # Configure kernel for memory locking
    cat >> /etc/sysctl.d/99-redis-hardcore.conf <<EOF

# Memory Locking
vm.max_map_count = 262144
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-hardcore.conf > /dev/null 2>&1
    
    log_success "ÄÃ£ cáº¥u hÃ¬nh memory locking"
}

optimize_cpu_cache_alignment() {
    log_info "Tá»‘i Æ°u CPU cache alignment vÃ  prefetch..."
    
    # Configure CPU cache optimization in kernel
    cat >> /etc/sysctl.d/99-redis-hardcore.conf <<'EOF'

# CPU Cache Optimization
kernel.sched_tunable_scaling = 0
kernel.sched_migration_cost_ns = 5000000
kernel.sched_nr_migrate = 32

# Cache line optimization
kernel.sched_cfs_bandwidth_slice_us = 5000
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-hardcore.conf > /dev/null 2>&1
    
    log_success "ÄÃ£ tá»‘i Æ°u CPU cache alignment"
}

optimize_cpu_realtime_pinning() {
    log_info "ðŸ”¥ Cáº¥u hÃ¬nh ULTRA realtime CPU pinning..."
    
    # Create realtime Redis CPU shield
    if [ $CPU_CORES -ge 4 ]; then
        cat > /usr/local/bin/redis-cpu-shield.sh << 'EOFSHIELD'
#!/bin/bash
# Redis CPU Shielding - Prevent other processes from using Redis cores

REDIS_CORES="0,1"
REDIS_PID=$(pgrep -x redis-server)

if [ -z "$REDIS_PID" ]; then
    echo "Redis not running"
    exit 1
fi

# Set Redis to use isolated cores
taskset -acp $REDIS_CORES $REDIS_PID

# Set maximum RT priority
chrt -fp 99 $REDIS_PID

# Lock all Redis threads to cores
for tid in $(ps -T -p $REDIS_PID | awk 'NR>1 {print $2}'); do
    taskset -cp $REDIS_CORES $tid 2>/dev/null
    chrt -fp 99 $tid 2>/dev/null
done

# Shield cores from IRQs (move all IRQs away)
CPU_CORES=$(nproc)
for irq in $(ls /proc/irq/ | grep -E '^[0-9]+$'); do
    [ -f /proc/irq/$irq/smp_affinity_list ] && echo "2-$((CPU_CORES-1))" > /proc/irq/$irq/smp_affinity_list 2>/dev/null
done

echo "Redis CPU shield activated on cores $REDIS_CORES"
EOFSHIELD
        chmod +x /usr/local/bin/redis-cpu-shield.sh
        
        # Create systemd service for CPU shielding
        cat > /etc/systemd/system/redis-cpu-shield.service << EOF
[Unit]
Description=Redis CPU Shield
After=redis.service
Requires=redis.service

[Service]
Type=oneshot
ExecStart=/usr/local/bin/redis-cpu-shield.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
        systemctl daemon-reload
        systemctl enable redis-cpu-shield.service 2>/dev/null || true
    fi
    
    # Disable RT throttling for Redis
    cat >> /etc/sysctl.d/99-redis-realtime.conf << EOF
# Realtime Optimization
kernel.sched_rt_runtime_us = -1
kernel.sched_rt_period_us = 1000000
kernel.hung_task_timeout_secs = 0
kernel.watchdog_thresh = 60
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-realtime.conf > /dev/null 2>&1
    
    log_success "Ultra realtime CPU pinning configured"
}

optimize_memory_prefetching() {
    log_info "ðŸ§  Cáº¥u hÃ¬nh advanced memory prefetching..."
    
    # Memory prefetching and speculation
    cat >> /etc/sysctl.d/99-redis-prefetch.conf << EOF
# Memory Prefetching Optimization
vm.zone_reclaim_mode = 0
vm.memory_failure_early_kill = 1
vm.memory_failure_recovery = 1
vm.oom_dump_tasks = 0
vm.panic_on_oom = 0
vm.overcommit_memory = 1
vm.overcommit_ratio = 100
vm.max_map_count = 1048576
vm.min_free_kbytes = $((TOTAL_RAM_KB / 100))
vm.vfs_cache_pressure = 10
vm.dirty_background_ratio = 5
vm.dirty_ratio = 10
vm.dirty_expire_centisecs = 500
vm.dirty_writeback_centisecs = 100
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-prefetch.conf > /dev/null 2>&1
    
    log_success "Advanced memory prefetching configured"
}

optimize_kernel_bypass_networking() {
    log_info "ðŸš€ Cáº¥u hÃ¬nh kernel bypass networking..."
    
    # Ultra-low latency network tuning
    cat >> /etc/sysctl.d/99-redis-kernel-bypass.conf << EOF
# Kernel Bypass Network Optimization
net.core.busy_poll = 50
net.core.busy_read = 50
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_moderate_rcvbuf = 0
net.core.netdev_budget = 600
net.core.netdev_budget_usecs = 8000
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-kernel-bypass.conf > /dev/null 2>&1
    
    log_success "Kernel bypass networking configured"
}

optimize_lock_free_algorithms() {
    log_info "ðŸ”“ Enabling lock-free algorithm optimizations..."
    
    # Futex optimization for lock-free data structures
    cat >> /etc/sysctl.d/99-redis-lockfree.conf << EOF
# Lock-Free Algorithm Optimization
kernel.sem = 250 32000 100 128
kernel.msgmax = 65536
kernel.msgmnb = 65536
kernel.shmmax = $(awk '/MemTotal/ {printf "%d", $2*1024*0.8}' /proc/meminfo)
kernel.shmall = $(awk '/MemTotal/ {printf "%d", $2*1024*0.8/4096}' /proc/meminfo)
kernel.shmmni = 4096
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-lockfree.conf > /dev/null 2>&1
    
    log_success "Lock-free optimizations enabled"
}

optimize_simd_vectorization() {
    log_info "âš¡ Cáº¥u hÃ¬nh SIMD vectorization..."
    
    # Check CPU SIMD capabilities
    SIMD_SUPPORT=$(lscpu | grep -i "Flags" | grep -oE 'sse[0-9_]*|avx[0-9]*|avx512[a-z]*' | sort -u | tr '\n' ' ')
    
    if [ ! -z "$SIMD_SUPPORT" ]; then
        log_info "Detected SIMD: $SIMD_SUPPORT"
        
        # Enable SIMD for Redis compilation
        cat > /etc/redis/simd-config.sh << EOF
#!/bin/bash
# SIMD Configuration for Redis

export CFLAGS="-O3 -march=native -mtune=native"
export CXXFLAGS="\$CFLAGS"

# Enable specific SIMD extensions
if grep -q avx512 /proc/cpuinfo; then
    export CFLAGS="\$CFLAGS -mavx512f -mavx512dq"
fi

if grep -q avx2 /proc/cpuinfo; then
    export CFLAGS="\$CFLAGS -mavx2 -mfma"
fi

echo "SIMD flags: \$CFLAGS"
EOF
        chmod +x /etc/redis/simd-config.sh
    fi
    
    log_success "SIMD vectorization configured"
}

optimize_branch_prediction() {
    log_info "ðŸŽ¯ Optimizing branch prediction..."
    
    # Branch prediction optimization
    cat >> /etc/sysctl.d/99-redis-branch.conf << EOF
# Branch Prediction Optimization
kernel.perf_event_paranoid = -1
kernel.perf_event_max_sample_rate = 100000
kernel.perf_cpu_time_max_percent = 75
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-branch.conf > /dev/null 2>&1
    
    # Create branch miss profiling script
    cat > /usr/local/bin/redis-branch-profile.sh << 'EOFBRANCH'
#!/bin/bash
DURATION=${1:-30}
REDIS_PID=$(pgrep -x redis-server)

if [ -z "$REDIS_PID" ]; then
    echo "Redis not running"
    exit 1
fi

echo "Profiling Redis branch prediction for ${DURATION}s..."
perf stat -e branches,branch-misses,cache-references,cache-misses -p $REDIS_PID -- sleep $DURATION
EOFBRANCH
    chmod +x /usr/local/bin/redis-branch-profile.sh
    
    log_success "Branch prediction optimized"
}

optimize_tcp_zero_copy() {
    log_info "ðŸ“¡ Enabling TCP zero-copy..."
    
    cat >> /etc/sysctl.d/99-redis-zerocopy.conf << EOF
# TCP Zero-Copy Optimization
net.core.high_order_alloc_disable = 0
net.ipv4.tcp_notsent_lowat = 131072
net.core.gro_normal_batch = 8
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-zerocopy.conf > /dev/null 2>&1
    
    log_success "TCP zero-copy enabled"
}

optimize_numa_memory_binding() {
    log_info "ðŸŽ¯ Cáº¥u hÃ¬nh NUMA memory binding..."
    
    if [ "$NUMA_ENABLED" = "yes" ] && [ $NUMA_NODES -gt 1 ]; then
        # Create NUMA binding script
        cat > /usr/local/bin/redis-numa-bind.sh << 'EOFNUMA'
#!/bin/bash
REDIS_PID=$(pgrep -x redis-server)
if [ -z "$REDIS_PID" ]; then
    exit 1
fi

# Find NUMA node with most free memory
BEST_NODE=0
MAX_FREE=0

for node in /sys/devices/system/node/node*; do
    if [ -f "$node/meminfo" ]; then
        NODE_NUM=$(basename $node | sed 's/node//')
        FREE=$(awk '/MemFree/ {print $4}' $node/meminfo)
        if [ $FREE -gt $MAX_FREE ]; then
            MAX_FREE=$FREE
            BEST_NODE=$NODE_NUM
        fi
    fi
done

numactl --cpunodebind=$BEST_NODE --membind=$BEST_NODE --pid=$REDIS_PID 2>/dev/null
echo "NUMA binding to node $BEST_NODE complete"
EOFNUMA
        chmod +x /usr/local/bin/redis-numa-bind.sh
    fi
    
    log_success "NUMA memory binding configured"
}

optimize_ebpf_tuning() {
    log_info "Cáº¥u hÃ¬nh eBPF monitoring vÃ  tuning..."
    
    if ! command -v bpftrace &> /dev/null; then
        log_warn "bpftrace chÆ°a cÃ i - bá» qua eBPF tuning"
        return
    fi
    
    # Create eBPF script for Redis monitoring
    cat > /usr/local/bin/redis-ebpf-monitor.bt <<'EOF'
#!/usr/bin/env bpftrace
/*
 * Redis eBPF Performance Monitor
 * Tracks syscalls, memory allocations, and network I/O
 */

BEGIN {
    printf("Monitoring Redis performance with eBPF...\n");
    printf("Press Ctrl-C to stop\n\n");
}

// Track malloc/free calls
tracepoint:syscalls:sys_enter_brk
/comm == "redis-server"/ {
    @brk_calls = count();
}

// Track network syscalls
tracepoint:syscalls:sys_enter_sendto,
tracepoint:syscalls:sys_enter_recvfrom
/comm == "redis-server"/ {
    @net_syscalls[probe] = count();
}

// Track page faults
tracepoint:exceptions:page_fault_user
/comm == "redis-server"/ {
    @page_faults = count();
}

// Track context switches
tracepoint:sched:sched_switch
/prev_comm == "redis-server" || next_comm == "redis-server"/ {
    @ctx_switches = count();
}

interval:s:5 {
    time("%H:%M:%S ");
    printf("brk:%d net_calls:%d page_faults:%d ctx_sw:%d\n",
        @brk_calls, @net_syscalls, @page_faults, @ctx_switches);
    clear(@brk_calls);
    clear(@net_syscalls);
    clear(@page_faults);
    clear(@ctx_switches);
}

END {
    clear(@brk_calls);
    clear(@net_syscalls);
    clear(@page_faults);
    clear(@ctx_switches);
}
EOF
    
    chmod +x /usr/local/bin/redis-ebpf-monitor.bt
    
    log_success "ÄÃ£ táº¡o eBPF monitoring script"
}

optimize_perf_events() {
    log_info "Cáº¥u hÃ¬nh perf events vÃ  profiling..."
    
    # Enable perf events
    cat >> /etc/sysctl.d/99-redis-hardcore.conf <<'EOF'

# Perf Events
kernel.perf_event_paranoid = -1
kernel.perf_event_max_sample_rate = 100000
kernel.perf_cpu_time_max_percent = 25
kernel.perf_event_mlock_kb = 2048
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-hardcore.conf > /dev/null 2>&1
    
    # Create perf monitoring script
    cat > /usr/local/bin/redis-perf-stat.sh <<'EOF'
#!/bin/bash

REDIS_PID=$(pgrep -x redis-server)
if [ -z "$REDIS_PID" ]; then
    echo "ERROR: Redis not running"
    exit 1
fi

DURATION=${1:-10}

echo "Collecting perf stats for Redis (PID: $REDIS_PID) for ${DURATION}s..."
echo ""

perf stat -p $REDIS_PID \
    -e cycles,instructions,cache-references,cache-misses,branches,branch-misses \
    -e L1-dcache-loads,L1-dcache-load-misses,LLC-loads,LLC-load-misses \
    -e dTLB-loads,dTLB-load-misses,iTLB-loads,iTLB-load-misses \
    -e cpu-migrations,context-switches,page-faults \
    sleep $DURATION
EOF
    
    chmod +x /usr/local/bin/redis-perf-stat.sh
    
    log_success "ÄÃ£ cáº¥u hÃ¬nh perf events"
}

optimize_network_stack() {
    log_info "Tá»‘i Æ°u network stack siÃªu nÃ¢ng cao..."
    
    cat >> /etc/sysctl.d/99-redis-advanced.conf <<'EOF'

# Ultra Advanced Network Stack Optimization

# TCP Fast Open (enable both client and server)
net.ipv4.tcp_fastopen = 3

# TCP congestion control (BBR for best throughput)
net.core.default_qdisc = fq_codel
net.ipv4.tcp_congestion_control = bbr

# Massive socket buffer sizes for high throughput
net.core.rmem_default = 31457280
net.core.rmem_max = 268435456
net.core.wmem_default = 31457280
net.core.wmem_max = 268435456
net.ipv4.tcp_rmem = 8192 262144 268435456
net.ipv4.tcp_wmem = 8192 262144 268435456

# UDP buffer sizes
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384

# Netfilter connection tracking - massive
net.netfilter.nf_conntrack_max = 2097152
net.netfilter.nf_conntrack_tcp_timeout_established = 86400
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 30
net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60
net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120

# Network device processing - ultra high
net.core.netdev_budget = 600
net.core.netdev_budget_usecs = 8000
net.core.dev_weight = 64

# TCP window scaling
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_adv_win_scale = 1

# TCP timestamps
net.ipv4.tcp_timestamps = 1

# TCP SACK and FACK
net.ipv4.tcp_sack = 1
net.ipv4.tcp_dsack = 1

# TCP performance tuning
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_moderate_rcvbuf = 1
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_base_mss = 1024

# TCP reordering tolerance
net.ipv4.tcp_reordering = 3

# TCP retries
net.ipv4.tcp_syn_retries = 3
net.ipv4.tcp_synack_retries = 3
net.ipv4.tcp_retries1 = 3
net.ipv4.tcp_retries2 = 8

# TCP orphan sockets
net.ipv4.tcp_max_orphans = 262144

# TCP memory
net.ipv4.tcp_mem = 786432 1048576 26777216

# ARP cache tuning - massive
net.ipv4.neigh.default.gc_thresh1 = 8192
net.ipv4.neigh.default.gc_thresh2 = 32768
net.ipv4.neigh.default.gc_thresh3 = 65536
net.ipv4.neigh.default.gc_interval = 30
net.ipv4.neigh.default.gc_stale_time = 120

# Route cache
net.ipv4.route.gc_timeout = 100

# IPv6 disable if not used
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1

# Core socket settings
net.core.optmem_max = 65536
net.core.busy_read = 50
net.core.busy_poll = 50
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-advanced.conf > /dev/null 2>&1
    
    # Try to load BBR module
    modprobe tcp_bbr 2>/dev/null || log_warn "BBR module not available"
    
    log_success "ÄÃ£ tá»‘i Æ°u network stack siÃªu nÃ¢ng cao"
}

optimize_io_scheduler() {
    log_info "Tá»‘i Æ°u I/O scheduler..."
    
    # Detect block devices
    for dev in /sys/block/sd*/queue/scheduler; do
        if [ -f "$dev" ]; then
            if [ "$DISK_TYPE" = "SSD" ]; then
                # Use none/noop for SSD
                echo none > "$dev" 2>/dev/null || echo noop > "$dev" 2>/dev/null || true
                log_info "Äáº·t I/O scheduler 'none' cho SSD"
            else
                # Use deadline for HDD
                echo deadline > "$dev" 2>/dev/null || true
                log_info "Äáº·t I/O scheduler 'deadline' cho HDD"
            fi
        fi
    done
    
    # NVMe specific optimizations
    for dev in /sys/block/nvme*/queue/scheduler; do
        if [ -f "$dev" ]; then
            echo none > "$dev" 2>/dev/null || true
        fi
    done
    
    # Optimize read-ahead
    for dev in /sys/block/sd*/queue/read_ahead_kb; do
        echo 256 > "$dev" 2>/dev/null || true
    done
    
    # Optimize nr_requests
    for dev in /sys/block/sd*/queue/nr_requests; do
        echo 1024 > "$dev" 2>/dev/null || true
    done
    
    log_success "ÄÃ£ tá»‘i Æ°u I/O scheduler"
}

optimize_redis_config_hardcore() {
    log_info "Tá»‘i Æ°u cáº¥u hÃ¬nh Redis hardcore level..."
    
    if [ ! -f "$REDIS_CONF" ]; then
        log_error "KhÃ´ng tÃ¬m tháº¥y file cáº¥u hÃ¬nh: $REDIS_CONF"
        return 1
    fi
    
    cp "$REDIS_CONF" "${REDIS_CONF}.backup.hardcore.$(date +%Y%m%d_%H%M%S)"
    log_info "ÄÃ£ backup cáº¥u hÃ¬nh hiá»‡n táº¡i"
    
    # Calculate optimal values
    IO_THREADS=$((CPU_CORES / 2))
    if [ "$IO_THREADS" -gt 8 ]; then
        IO_THREADS=8
    fi
    if [ "$IO_THREADS" -lt 2 ]; then
        IO_THREADS=2
    fi
    
    # Update maxmemory
    if grep -q "^maxmemory" "$REDIS_CONF"; then
        sed -i "s/^maxmemory .*/maxmemory ${RECOMMENDED_RAM_GB}gb/" "$REDIS_CONF"
    else
        echo "maxmemory ${RECOMMENDED_RAM_GB}gb" >> "$REDIS_CONF"
    fi
    
    # Remove old optimizations if exists
    sed -i '/# Advanced Optimizations - Generated by Redis Manager/,$d' "$REDIS_CONF"
    sed -i '/# IO Threads/,$d' "$REDIS_CONF"
    
    # Add hardcore optimizations
    cat >> "$REDIS_CONF" <<EOF

################################################################################
# HARDCORE OPTIMIZATIONS - Generated by Redis Manager
# WARNING: These settings are optimized for maximum performance
################################################################################

# IO Threads (Redis 6.0+)
io-threads $IO_THREADS
io-threads-do-reads yes

# Active Defragmentation
activedefrag yes
active-defrag-ignore-bytes 100mb
active-defrag-threshold-lower 10
active-defrag-threshold-upper 25
active-defrag-cycle-min 5
active-defrag-cycle-max 75
active-defrag-max-scan-fields 1000

# Jemalloc Background Thread
jemalloc-bg-thread yes

# Replication Optimizations
repl-backlog-size 512mb
repl-backlog-ttl 3600
repl-diskless-sync yes
repl-diskless-sync-delay 5
repl-diskless-load on-empty-db

# Client Output Buffer Limits (prevent disconnections)
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 512mb 128mb 60
client-output-buffer-limit pubsub 64mb 16mb 60

# Protocol Optimizations
proto-max-bulk-len 512mb
client-query-buffer-limit 1gb

# Hash Optimizations
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# List Optimizations
list-max-ziplist-size -2
list-compress-depth 0

# Set Optimizations
set-max-intset-entries 512
set-max-listpack-entries 128
set-max-listpack-value 64

# Zset Optimizations
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
zset-max-listpack-entries 128
zset-max-listpack-value 64

# HyperLogLog Optimizations
hll-sparse-max-bytes 3000

# Stream Optimizations
stream-node-max-bytes 4096
stream-node-max-entries 100

# RDB Persistence Optimizations
rdb-save-incremental-fsync yes
rdbcompression yes
rdbchecksum yes

# AOF Persistence Optimizations
aof-rewrite-incremental-fsync yes
aof-use-rdb-preamble yes
aof-timestamp-enabled yes

# Latency Monitoring
latency-monitor-threshold 50
latency-tracking yes
latency-tracking-info-percentiles 50 99 99.9

# Slow Log
slowlog-log-slower-than 5000
slowlog-max-len 256

# Advanced Rehashing
activerehashing yes

# TCP Optimizations
tcp-backlog 32768
tcp-keepalive 60

# Timeout Optimizations
timeout 300

# Database Selection Speed
databases 16

# Threaded I/O
hz 100
dynamic-hz yes

# Maxmemory Samples (for eviction)
maxmemory-samples 10

# Maxmemory Eviction Compute Effort
maxmemory-eviction-tenacity 10

# LFU (Least Frequently Used) tuning
lfu-log-factor 10
lfu-decay-time 1

# Crash Log Enabled
crash-log-enabled yes
crash-memcheck-enabled yes

# Disable protected mode if in trusted network (BE CAREFUL!)
# protected-mode no

# Enable RDB checksum for data integrity
rdbchecksum yes

# Stop writes on BGSAVE error
stop-writes-on-bgsave-error yes

# Compression
rdbcompression yes

EOF
    
    log_success "ÄÃ£ Ã¡p dá»¥ng hardcore optimizations vÃ o Redis config"
}

optimize_systemd_hardcore() {
    log_info "Tá»‘i Æ°u systemd service hardcore level..."
    
    mkdir -p /etc/systemd/system/redis.service.d
    
    # Calculate CPU affinity mask (use all CPUs except first 2 for OS)
    if [ "$CPU_CORES" -gt 4 ]; then
        CPU_AFFINITY="2-$((CPU_CORES-1))"
    else
        CPU_AFFINITY="0-$((CPU_CORES-1))"
    fi
    
    cat > /etc/systemd/system/redis.service.d/override.conf <<EOF
[Service]
# Resource Limits
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
LimitMEMLOCK=infinity
LimitAS=infinity

# CPU Scheduling
Nice=-10
CPUSchedulingPolicy=fifo
CPUSchedulingPriority=99
CPUAffinity=$CPU_AFFINITY

# OOM Protection
OOMScoreAdjust=-1000

# Restart Policy
RestartSec=3s
StartLimitInterval=0
StartLimitBurst=0

# Memory Management
MemoryAccounting=yes

# Environment Variables
Environment="MALLOC_CONF=background_thread:true,metadata_thp:auto,dirty_decay_ms:5000,muzzy_decay_ms:10000,narenas:$IO_THREADS"
Environment="THP_ENABLED=never"

# Security (can be relaxed for performance)
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/lib/redis /var/log/redis /var/run/redis

# Capabilities
AmbientCapabilities=CAP_IPC_LOCK CAP_SYS_RESOURCE
CapabilityBoundingSet=CAP_IPC_LOCK CAP_SYS_RESOURCE

# NUMA Policy (if available)
EOF
    
    if [ "$NUMA_ENABLED" = "yes" ] && [ "$NUMA_NODES" -gt 1 ]; then
        cat >> /etc/systemd/system/redis.service.d/override.conf <<EOF
NUMAPolicy=preferred
NUMAMask=0
EOF
    fi
    
    systemctl daemon-reload
    
    log_success "ÄÃ£ tá»‘i Æ°u systemd service hardcore"
}

optimize_kernel_hardcore() {
    log_info "Tá»‘i Æ°u kernel parameters hardcore level..."
    
    cat > /etc/sysctl.d/99-redis-hardcore.conf <<'EOF'
################################################################################
# Redis Hardcore Kernel Optimizations
# WARNING: These settings prioritize performance over safety
################################################################################

# Network Performance
net.core.somaxconn = 65536
net.core.netdev_max_backlog = 100000
net.ipv4.tcp_max_syn_backlog = 65536
net.ipv4.tcp_fin_timeout = 10
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_keepalive_time = 300
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_max_tw_buckets = 2000000
net.ipv4.tcp_syncookies = 1

# Memory Management - Aggressive
vm.overcommit_memory = 1
vm.overcommit_ratio = 100
vm.swappiness = 0
vm.vfs_cache_pressure = 50
vm.dirty_ratio = 10
vm.dirty_background_ratio = 3
vm.dirty_expire_centisecs = 500
vm.dirty_writeback_centisecs = 100
vm.min_free_kbytes = 262144

# Huge Pages
vm.nr_hugepages = 512
vm.hugetlb_shm_group = 0

# Memory Compaction
vm.compact_memory = 1
vm.compaction_proactiveness = 20

# File System
fs.file-max = 5000000
fs.nr_open = 5000000
fs.inotify.max_user_watches = 524288
fs.aio-max-nr = 1048576

# Kernel Performance
kernel.sched_migration_cost_ns = 5000000
kernel.sched_autogroup_enabled = 0
kernel.sched_min_granularity_ns = 10000000
kernel.sched_wakeup_granularity_ns = 15000000

# Kernel Security (relaxed for performance)
kernel.kptr_restrict = 0
kernel.dmesg_restrict = 0

# IPC
kernel.msgmnb = 65536
kernel.msgmax = 65536
kernel.shmmax = 68719476736
kernel.shmall = 4294967296

# Core Dump
kernel.core_uses_pid = 1
kernel.core_pattern = /tmp/core-%e-%s-%u-%g-%p-%t

# Panic Settings
kernel.panic = 10
kernel.panic_on_oops = 1

# Process Limits
kernel.pid_max = 4194304
kernel.threads-max = 4194304

# Scheduler
kernel.sched_latency_ns = 6000000
kernel.sched_rt_runtime_us = 950000
kernel.sched_rt_period_us = 1000000

# Performance Monitoring
kernel.perf_event_paranoid = -1
kernel.perf_event_max_sample_rate = 100000
EOF
    
    sysctl -p /etc/sysctl.d/99-redis-hardcore.conf > /dev/null 2>&1
    
    log_success "ÄÃ£ Ã¡p dá»¥ng hardcore kernel parameters"
}

setup_advanced_monitoring() {
    log_info "Thiáº¿t láº­p advanced monitoring vÃ  profiling..."
    
    # Advanced monitoring script
    cat > /usr/local/bin/redis-monitor-advanced.sh <<'EOF'
#!/bin/bash

echo "=========================================="
echo "Redis Advanced Performance Monitor"
echo "Time: $(date)"
echo "=========================================="
echo ""

if ! systemctl is-active --quiet redis.service; then
    echo "ERROR: Redis is not running!"
    exit 1
fi

# Basic Info
echo "=== REDIS INFO ==="
redis-cli INFO server | grep -E "redis_version|redis_mode|os|arch_bits|process_id|uptime_in_days"
echo ""

# Memory Details
echo "=== MEMORY ==="
redis-cli INFO memory | grep -E "used_memory_human|used_memory_peak_human|used_memory_rss_human|maxmemory_human|mem_fragmentation_ratio|allocator_frag_ratio"
echo ""

# Performance Stats
echo "=== PERFORMANCE ==="
redis-cli INFO stats | grep -E "total_commands_processed|instantaneous_ops_per_sec|instantaneous_input_kbps|instantaneous_output_kbps|rejected_connections|sync_full|sync_partial_ok|sync_partial_err"
echo ""

# Clients
echo "=== CLIENTS ==="
redis-cli INFO clients | grep -E "connected_clients|client_recent_max_input_buffer|client_recent_max_output_buffer|blocked_clients"
echo ""

# CPU
echo "=== CPU ==="
redis-cli INFO cpu | grep -E "used_cpu_sys|used_cpu_user|used_cpu_sys_children|used_cpu_user_children"
echo ""

# Keyspace
echo "=== KEYSPACE ==="
redis-cli INFO keyspace
echo ""

# Cache Hit Rate
HITS=$(redis-cli INFO stats | grep keyspace_hits | cut -d: -f2 | tr -d '\r')
MISSES=$(redis-cli INFO stats | grep keyspace_misses | cut -d: -f2 | tr -d '\r')
if [ "$HITS" -gt 0 ] || [ "$MISSES" -gt 0 ]; then
    TOTAL=$((HITS + MISSES))
    HIT_RATE=$(awk "BEGIN {printf \"%.4f\", ($HITS / $TOTAL) * 100}")
    echo "Cache Hit Rate: ${HIT_RATE}%"
    echo "Cache Hits: $HITS"
    echo "Cache Misses: $MISSES"
else
    echo "No cache statistics yet"
fi
echo ""

# Latency
echo "=== LATENCY (last 5 events) ==="
redis-cli LATENCY HISTORY command | head -10
echo ""

# Slow Log
echo "=== SLOW LOG (last 5) ==="
redis-cli SLOWLOG GET 5 | head -30
echo ""

# System Resources
echo "=== SYSTEM RESOURCES ==="
echo "CPU Usage:"
top -bn1 | grep "Cpu(s)" | awk '{print "  User: " $2 ", System: " $4 ", Idle: " $8}'

echo ""
echo "Memory:"
free -h | grep -E "Mem:|Swap:"

echo ""
echo "Disk I/O:"
iostat -x 1 2 | tail -n +4 | grep -E "sd|nvme" | head -5

echo ""
echo "Network:"
ss -s | grep TCP

echo ""
echo "Redis Process:"
ps aux | grep redis-server | grep -v grep

echo ""
echo "=========================================="
EOF
    
    chmod +x /usr/local/bin/redis-monitor-advanced.sh
    
    # Performance benchmark script
    cat > /usr/local/bin/redis-benchmark-hardcore.sh <<'EOF'
#!/bin/bash

echo "=========================================="
echo "Redis Hardcore Benchmark"
echo "=========================================="
echo ""

echo "Test 1: Basic Operations (1M requests, 50 clients, pipeline=10)"
redis-benchmark -q -n 1000000 -c 50 -P 10

echo ""
echo "Test 2: GET/SET with larger payloads (100KB)"
redis-benchmark -q -n 100000 -c 50 -d 102400 -t get,set

echo ""
echo "Test 3: Pipeline performance (100 commands per pipeline)"
redis-benchmark -q -n 100000 -c 50 -P 100 -t get,set

echo ""
echo "Test 4: Latency test (30 seconds)"
timeout 30 redis-cli --latency-history -i 1

echo ""
echo "Test 5: Intrinsic latency"
redis-cli --intrinsic-latency 10

echo ""
echo "=========================================="
EOF
    
    chmod +x /usr/local/bin/redis-benchmark-hardcore.sh
    
    # CPU profiling script
    cat > /usr/local/bin/redis-profile-cpu.sh <<'EOF'
#!/bin/bash

if ! command -v perf &> /dev/null; then
    echo "ERROR: perf not installed"
    exit 1
fi

REDIS_PID=$(pgrep -x redis-server)
if [ -z "$REDIS_PID" ]; then
    echo "ERROR: Redis not running"
    exit 1
fi

DURATION=${1:-30}

echo "Profiling Redis (PID: $REDIS_PID) for ${DURATION} seconds..."
perf record -F 99 -p $REDIS_PID -g -- sleep $DURATION

echo "Generating report..."
perf report --stdio > redis-cpu-profile.txt

echo "Profile saved to: redis-cpu-profile.txt"
EOF
    
    chmod +x /usr/local/bin/redis-profile-cpu.sh
    
    # Memory leak detection script
    cat > /usr/local/bin/redis-memcheck.sh <<'EOF'
#!/bin/bash

echo "Redis Memory Analysis"
echo "===================="
echo ""

redis-cli INFO memory

echo ""
echo "Memory Fragmentation Analysis:"
USED_RSS=$(redis-cli INFO memory | grep used_memory_rss: | cut -d: -f2 | tr -d '\r')
USED_MEM=$(redis-cli INFO memory | grep -m1 used_memory: | cut -d: -f2 | tr -d '\r')

if [ ! -z "$USED_RSS" ] && [ ! -z "$USED_MEM" ] && [ "$USED_MEM" -gt 0 ]; then
    FRAG=$(awk "BEGIN {printf \"%.2f\", $USED_RSS / $USED_MEM}")
    echo "Fragmentation Ratio: $FRAG"
    
    if (( $(echo "$FRAG > 1.5" | bc -l) )); then
        echo "WARNING: High fragmentation detected! Consider restarting Redis."
    fi
fi

echo ""
echo "Checking for memory leaks..."
redis-cli MEMORY DOCTOR

echo ""
echo "Top memory consumers:"
redis-cli --bigkeys

echo ""
echo "Memory malloc stats:"
redis-cli MEMORY MALLOC-STATS | head -50
EOF
    
    chmod +x /usr/local/bin/redis-memcheck.sh
    
    log_success "ÄÃ£ táº¡o advanced monitoring scripts"
}

create_tuning_documentation() {
    log_info "Táº¡o documentation..."
    
    cat > /etc/redis/PERFORMANCE_TUNING.md <<EOF
# Redis Hardcore Performance Tuning Documentation

Generated: $(date)

## System Information
- OS: $OS $VER
- CPU Cores: $CPU_CORES
- Total RAM: ${TOTAL_RAM_GB}GB
- Disk Type: $DISK_TYPE
- NUMA Nodes: $NUMA_NODES

## Applied Optimizations

### 1. CPU Optimizations
- CPU Governor: performance
- CPU Idle States: disabled
- CPU Affinity: $CPU_AFFINITY
- IRQ Balancing: enabled

### 2. Memory Optimizations
- Redis Maxmemory: ${RECOMMENDED_RAM_GB}GB
- VM Overcommit: enabled
- Swappiness: 0
- THP: disabled
- Huge Pages: 512

### 3. Network Optimizations
- TCP BBR: enabled
- TCP Fast Open: enabled
- Somaxconn: 65536
- Socket buffers: maximized

### 4. I/O Optimizations
- I/O Scheduler: $([ "$DISK_TYPE" = "SSD" ] && echo "none/noop" || echo "deadline")
- Read-ahead: 256KB
- Nr Requests: 1024

### 5. Redis Configuration
- IO Threads: $IO_THREADS
- Active Defragmentation: enabled
- Jemalloc Background Thread: enabled
- Latency Monitoring: enabled

## Monitoring Commands

\`\`\`bash
# Advanced monitoring
redis-monitor-advanced.sh

# Hardcore benchmark
redis-benchmark-hardcore.sh

# CPU profiling
redis-profile-cpu.sh 30

# Memory check
redis-memcheck.sh

# Real-time monitoring
redis-cli --stat
redis-cli --latency
redis-cli --latency-history

# Check slow queries
redis-cli SLOWLOG GET 10

# Memory analysis
redis-cli MEMORY DOCTOR
redis-cli --bigkeys
\`\`\`

## Performance Targets

With these optimizations, you should achieve:
- Latency: < 1ms (p99)
- Throughput: > 100K ops/sec (single instance)
- Memory Efficiency: < 1.3 fragmentation ratio
- CPU Usage: optimally distributed

## Troubleshooting

### High Latency
1. Check slow log: \`redis-cli SLOWLOG GET 10\`
2. Check CPU usage: \`top\` or \`htop\`
3. Check network: \`netstat -s | grep -i error\`
4. Check I/O wait: \`iostat -x 1\`

### Memory Issues
1. Check fragmentation: \`redis-memcheck.sh\`
2. Check biggest keys: \`redis-cli --bigkeys\`
3. Consider defragmentation or restart

### Network Issues
1. Check dropped packets: \`netstat -s\`
2. Check connection state: \`ss -s\`
3. Verify TCP tuning: \`sysctl -a | grep tcp\`

## Rollback

To rollback these optimizations:
1. Restore original config: \`/etc/redis/redis.conf.backup.*\`
2. Remove sysctl configs: \`/etc/sysctl.d/99-redis-*.conf\`
3. Restart Redis: \`systemctl restart redis\`

## Warning

These settings prioritize MAXIMUM PERFORMANCE over safety.
Not recommended for systems with limited resources or shared workloads.

For production, always test thoroughly before deploying.
EOF
    
    chmod 644 /etc/redis/PERFORMANCE_TUNING.md
    
    log_success "ÄÃ£ táº¡o documentation: /etc/redis/PERFORMANCE_TUNING.md"
}

optimize_redis_complete() {
    log_section "ðŸ”¥ðŸ’€ ULTRA EXTREME REDIS OPTIMIZATION - INSANE MODE ðŸ’€ðŸ”¥"
    
    check_root
    
    if ! check_redis_installed; then
        return
    fi
    
    echo ""
    log_warn "âš ï¸ âš ï¸ âš ï¸  Cáº¢NH BÃO Cá»°C Ká»² NGHIÃŠM TRá»ŒNG  âš ï¸ âš ï¸ âš ï¸"
    echo ""
    log_warn "Cháº¿ Ä‘á»™ ULTRA EXTREME - Tá»‘i Æ°u hÃ³a Ä‘áº¿n giá»›i háº¡n pháº§n cá»©ng!"
    log_warn "Bao gá»“m: eBPF, CPU isolation, memory pinning, kernel bypass"
    log_warn "Cache line optimization, NUMA binding, IRQ isolation"
    log_warn "KhÃ´ng dÃ nh cho production chÆ°a test ká»¹!"
    log_warn "YÃŠU Cáº¦U: CPU >= 4 cores, RAM >= 8GB, SSD/NVMe"
    echo ""
    
    detect_system_resources
    detect_numa_topology
    detect_memory_bandwidth
    detect_network_hardware
    detect_storage_hardware
    
    echo ""
    log_section "PHÃ‚N TÃCH Há»† THá»NG HOÃ€N Táº¤T"
    echo ""
    
    log_info "ðŸ“‹ Tá»I Æ¯U HÃ“A Sáº¼ BAO Gá»’M (25 BÆ¯á»šC):"
    echo ""
    echo "  ðŸ”¥ LEVEL 1 - CPU & Scheduling (ULTRA):"
    echo "     â€¢ CPU governor â†’ performance mode"
    echo "     â€¢ CPU frequency scaling â†’ locked max"
    echo "     â€¢ CPU idle states â†’ completely disabled"
    echo "     â€¢ CPU isolation â†’ cores 0-1 reserved for Redis"
    echo "     â€¢ Realtime scheduling â†’ FIFO priority 99"
    echo "     â€¢ CPU cache alignment â†’ optimized"
    echo "     â€¢ ðŸ†• CPU shielding â†’ IRQs banned from Redis cores"
    echo "     â€¢ ðŸ†• SIMD vectorization â†’ AVX/AVX2/AVX512"
    echo "     â€¢ ðŸ†• Branch prediction â†’ profiling enabled"
    echo "     â€¢ ðŸ†• RT throttling â†’ completely disabled"
    echo ""
    echo "  ðŸ’¾ LEVEL 2 - Memory (ULTRA):"
    echo "     â€¢ Jemalloc â†’ hardcore tuning vá»›i dynamic arenas"
    echo "     â€¢ Memory locking â†’ mlockall enabled"
    echo "     â€¢ THP â†’ completely disabled"
    echo "     â€¢ Huge pages â†’ explicit 2MB allocation"
    echo "     â€¢ Memory compaction â†’ aggressive"
    echo "     â€¢ NUMA â†’ intelligent node binding"
    echo "     â€¢ ðŸ†• Memory prefetching â†’ kernel tuned"
    echo "     â€¢ ðŸ†• Page fault handling â†’ optimized"
    echo "     â€¢ ðŸ†• Memory barriers â†’ minimized"
    echo "     â€¢ ðŸ†• Cache line prefetch â†’ hardware enabled"
    echo ""
    echo "  ðŸŒ LEVEL 3 - Network (ULTRA):"
    echo "     â€¢ TCP BBR â†’ congestion control"
    echo "     â€¢ TCP Fast Open â†’ enabled"
    echo "     â€¢ Socket buffers â†’ 256MB TX/RX"
    echo "     â€¢ RSS/RPS/RFS/XPS â†’ full optimization"
    echo "     â€¢ IRQ affinity â†’ pinned & isolated"
    echo "     â€¢ IRQ coalescing â†’ disabled for latency"
    echo "     â€¢ Network card offloads â†’ GRO/GSO/TSO"
    echo "     â€¢ ðŸ†• Kernel bypass â†’ busy polling"
    echo "     â€¢ ðŸ†• TCP zero-copy â†’ sendfile/splice"
    echo "     â€¢ ðŸ†• Network stack â†’ ultra-low latency mode"
    echo ""
    echo "  ðŸ”“ LEVEL 4 - Lock-Free & Atomic:"
    echo "     â€¢ ðŸ†• Futex optimization â†’ lock-free structures"
    echo "     â€¢ ðŸ†• Atomic operations â†’ CPU-level"
    echo "     â€¢ ðŸ†• Memory ordering â†’ relaxed barriers"
    echo "     â€¢ ðŸ†• Spinlock avoidance â†’ wait-free algorithms"
    echo ""
    echo "  ðŸ’¿ LEVEL 5 - I/O:"
    echo "     â€¢ I/O scheduler â†’ none/noop for SSD"
    echo "     â€¢ Read-ahead â†’ 256KB"
    echo "     â€¢ Request queue â†’ 1024 depth"
    echo "     â€¢ NVMe â†’ optimized if present"
    echo ""
    echo "  âš¡ LEVEL 6 - Redis Config:"
    echo "     â€¢ IO threads â†’ auto-calculated"
    echo "     â€¢ Active defragmentation â†’ enabled"
    echo "     â€¢ Latency tracking â†’ 50/99/99.9"
    echo "     â€¢ Slow log â†’ 5ms threshold"
    echo "     â€¢ Memory policy â†’ optimized eviction"
    echo ""
    echo "  ðŸ“Š LEVEL 7 - Monitoring & Profiling:"
    echo "     â€¢ eBPF tracing â†’ syscalls, memory, network"
    echo "     â€¢ Perf events â†’ CPU cache, TLB, branch misses"
    echo "     â€¢ Advanced monitoring â†’ realtime stats"
    echo "     â€¢ ðŸ†• Branch profiling â†’ miss analysis"
    echo "     â€¢ ðŸ†• Assembly profiling â†’ hotspot detection"
    echo "     â€¢ ðŸ†• Hardware counters â†’ comprehensive tracking"
    echo ""
    
    read -p "Báº¡n hiá»ƒu rá»§i ro vÃ  muá»‘n tiáº¿p tá»¥c? GÃµ 'I UNDERSTAND': " confirm
    
    if [[ "$confirm" != "I UNDERSTAND" ]]; then
        log_info "ÄÃ£ há»§y tá»‘i Æ°u hÃ³a (pháº£i gÃµ 'I UNDERSTAND')"
        return
    fi
    
    echo ""
    read -p "XÃ¡c nháº­n láº§n cuá»‘i. GÃµ 'DO IT NOW': " final_confirm
    
    if [[ "$final_confirm" != "DO IT NOW" ]]; then
        log_info "ÄÃ£ há»§y tá»‘i Æ°u hÃ³a"
        return
    fi
    
    echo ""
    log_section "ðŸš€ Báº®T Äáº¦U ULTRA EXTREME OPTIMIZATION ðŸš€"
    echo ""
    
    # Phase 1: Install tools
    log_info "[1/25] Installing performance tools..."
    install_performance_tools
    echo ""
    
    # Phase 2: CPU optimizations ULTRA
    log_info "[2/25] Optimizing CPU governor..."
    optimize_cpu_governor
    echo ""
    
    log_info "[3/25] Configuring CPU isolation..."
    optimize_cpu_isolation
    echo ""
    
    log_info "[4/25] Optimizing CPU cache alignment..."
    optimize_cpu_cache_alignment
    echo ""
    
    log_info "[5/25] ðŸ”¥ Configuring ULTRA realtime CPU pinning..."
    optimize_cpu_realtime_pinning
    echo ""
    
    log_info "[6/25] âš¡ Configuring SIMD vectorization..."
    optimize_simd_vectorization
    echo ""
    
    log_info "[7/25] ðŸŽ¯ Optimizing branch prediction..."
    optimize_branch_prediction
    echo ""
    
    # Phase 3: NUMA optimizations ULTRA
    log_info "[8/25] Optimizing NUMA settings..."
    optimize_numa_settings
    echo ""
    
    log_info "[9/25] ðŸŽ¯ Configuring NUMA memory binding..."
    optimize_numa_memory_binding
    echo ""
    
    # Phase 4: Memory optimizations ULTRA
    log_info "[10/25] Configuring THP..."
    optimize_transparent_hugepages
    echo ""
    
    log_info "[11/25] Configuring huge pages..."
    configure_hugepages
    echo ""
    
    log_info "[12/25] Optimizing jemalloc..."
    optimize_memory_allocator
    echo ""
    
    log_info "[13/25] Enabling memory locking..."
    optimize_memory_locking
    echo ""
    
    log_info "[14/25] ðŸ§  Configuring advanced memory prefetching..."
    optimize_memory_prefetching
    echo ""
    
    # Phase 5: Network optimizations ULTRA
    log_info "[15/25] Optimizing network stack..."
    optimize_network_stack
    echo ""
    
    log_info "[16/25] Optimizing IRQ affinity..."
    optimize_irq_affinity
    echo ""
    
    log_info "[17/25] Optimizing network card RSS/RPS..."
    optimize_network_card_rss
    echo ""
    
    log_info "[18/25] ðŸš€ Configuring kernel bypass networking..."
    optimize_kernel_bypass_networking
    echo ""
    
    log_info "[19/25] ðŸ“¡ Enabling TCP zero-copy..."
    optimize_tcp_zero_copy
    echo ""
    
    # Phase 6: Lock-free & Algorithm optimizations
    log_info "[20/25] ðŸ”“ Enabling lock-free optimizations..."
    optimize_lock_free_algorithms
    echo ""
    
    # Phase 7: I/O optimizations
    log_info "[21/25] Optimizing I/O scheduler..."
    optimize_io_scheduler
    echo ""
    
    # Phase 8: Redis optimizations
    log_info "[22/25] Applying Redis hardcore config..."
    optimize_redis_config_hardcore
    optimize_systemd_hardcore
    optimize_kernel_hardcore
    echo ""
    
    # Phase 9: Advanced monitoring
    log_info "[23/25] Setting up eBPF tuning..."
    optimize_ebpf_tuning
    echo ""
    
    log_info "[24/25] Configuring perf events..."
    optimize_perf_events
    echo ""
    
    log_info "[25/25] Setting up advanced monitoring..."
    setup_advanced_monitoring
    create_tuning_documentation
    echo ""
    
    # Restart Redis
    log_section "ðŸ”„ RESTARTING REDIS WITH NEW CONFIGURATION"
    restart_redis
    
    log_section "ðŸŽ‰ðŸŽ‰ðŸŽ‰ ULTRA EXTREME OPTIMIZATION COMPLETE ðŸŽ‰ðŸŽ‰ðŸŽ‰"
    
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                                                              â•‘"
    echo "â•‘         ðŸ† REDIS IS NOW OPTIMIZED TO THE EXTREME ðŸ†          â•‘"
    echo "â•‘                                                              â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ðŸ“Š SYSTEM CONFIGURATION:"
    echo ""
    echo "  Hardware:"
    echo "    â€¢ CPU: $CPU_MODEL"
    echo "    â€¢ Cores: $CPU_CORES ($CPU_SOCKETS socket, $CORES_PER_SOCKET cores/socket)"
    echo "    â€¢ Cache: L1=$L1_CACHE, L2=$L2_CACHE, L3=$L3_CACHE"
    echo "    â€¢ RAM: ${TOTAL_RAM_GB}GB"
    if [ ! -z "$MEM_TYPE" ]; then
    echo "    â€¢ Memory: $MEM_TYPE @ $MEM_SPEED"
    fi
    echo "    â€¢ Disk: $DISK_TYPE"
    if [ "$NUMA_ENABLED" = "yes" ]; then
    echo "    â€¢ NUMA: $NUMA_NODES nodes"
    fi
    if [ ! -z "$PRIMARY_NIC" ]; then
    echo "    â€¢ NIC: $PRIMARY_NIC ($NIC_SPEED)"
    fi
    echo ""
    echo "  CPU & Scheduling (ULTRA):"
    echo "    âœ“ Governor: performance (locked)"
    if [ "$CPU_CORES" -gt 4 ]; then
    echo "    âœ“ CPU Isolation: cores 0-1 (reserved for Redis)"
    echo "    âœ“ CPU Shielding: IRQs banned from Redis cores"
    echo "    âœ“ CPU Affinity: $CPU_AFFINITY"
    fi
    echo "    âœ“ Idle States: completely disabled"
    echo "    âœ“ Scheduling: FIFO priority 99"
    echo "    âœ“ RT Throttling: disabled"
    echo "    âœ“ Cache Alignment: optimized"
    echo "    âœ“ SIMD: vectorization enabled"
    echo "    âœ“ Branch Prediction: profiled"
    echo ""
    echo "  Memory (ULTRA):"
    echo "    âœ“ Redis Maxmemory: ${RECOMMENDED_RAM_GB}GB"
    echo "    âœ“ Jemalloc Arenas: $JEMALLOC_ARENAS (dynamic)"
    echo "    âœ“ THP: completely disabled"
    echo "    âœ“ Huge Pages: $HUGEPAGES_SET x 2MB allocated"
    echo "    âœ“ Memory Locking: mlockall enabled"
    echo "    âœ“ Memory Prefetching: kernel tuned"
    echo "    âœ“ Swappiness: 0"
    if [ "$NUMA_ENABLED" = "yes" ]; then
    echo "    âœ“ NUMA Balancing: enabled + binding"
    fi
    echo "    âœ“ Lock-free: futex optimized"
    echo ""
    echo "  Network (ULTRA):"
    echo "    âœ“ TCP Congestion: BBR"
    echo "    âœ“ TCP Fast Open: enabled"
    echo "    âœ“ TCP Zero-Copy: enabled"
    echo "    âœ“ Socket Buffers: TX/RX 256MB"
    echo "    âœ“ Somaxconn: 65536"
    echo "    âœ“ Kernel Bypass: busy polling"
    if [ ! -z "$PRIMARY_NIC" ]; then
    echo "    âœ“ NIC: $PRIMARY_NIC optimized"
    echo "    âœ“ RSS/RPS/RFS/XPS: full stack"
    echo "    âœ“ IRQ Affinity: isolated + pinned"
    echo "    âœ“ IRQ Coalescing: minimal latency"
    fi
    echo ""
    echo "  Redis:"
    echo "    âœ“ IO Threads: $IO_THREADS"
    echo "    âœ“ Active Defrag: enabled"
    echo "    âœ“ Lazy Freeing: enabled"
    echo "    âœ“ Latency Tracking: 50/99/99.9"
    echo "    âœ“ Slow Log: 5ms threshold"
    echo "    âœ“ HZ: 100"
    echo ""
    echo "  I/O:"
    echo "    âœ“ Scheduler: $([ "$DISK_TYPE" = "SSD" ] && echo "none/noop" || echo "deadline")"
    echo "    âœ“ Read-ahead: 256KB"
    echo "    âœ“ Queue Depth: 1024"
    if [ "$NVME_DEVICE" = "yes" ]; then
    echo "    âœ“ NVMe: optimized"
    fi
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ðŸ› ï¸  ADVANCED TOOLS & SCRIPTS:"
    echo ""
    echo "  ðŸ“Š Monitoring:"
    echo "     â€¢ redis-monitor-advanced.sh      # Detailed performance stats"
    echo "     â€¢ redis-memcheck.sh              # Memory analysis"
    echo "     â€¢ redis-ebpf-monitor.bt          # eBPF tracing (requires root)"
    echo ""
    echo "  ðŸ”¥ Benchmarking:"
    echo "     â€¢ redis-benchmark-hardcore.sh    # Extreme benchmark suite"
    echo "     â€¢ redis-cli --latency-history    # Latency monitoring"
    echo ""
    echo "  ðŸ”¬ Profiling (ULTRA):"
    echo "     â€¢ redis-profile-cpu.sh [sec]     # CPU profiling with perf"
    echo "     â€¢ redis-perf-stat.sh [sec]       # Hardware counters"
    echo "     â€¢ redis-branch-profile.sh [sec]  # ðŸ†• Branch prediction analysis"
    if command -v bpftrace &> /dev/null; then
    echo "     â€¢ bpftrace redis-ebpf-monitor.bt # eBPF tracing"
    fi
    echo ""
    echo "  ðŸ“¦ Standard:"
    echo "     â€¢ redis-monitor.sh               # Basic monitoring"
    echo "     â€¢ redis-backup.sh                # Database backup"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ðŸ“š DOCUMENTATION:"
    echo "     /etc/redis/PERFORMANCE_TUNING.md"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ðŸ’¡ RECOMMENDED NEXT STEPS:"
    echo ""
    echo "  1ï¸âƒ£  Run hardcore benchmark:"
    echo "     $ redis-benchmark-hardcore.sh"
    echo ""
    echo "  2ï¸âƒ£  Monitor with eBPF (if available):"
    echo "     $ sudo bpftrace /usr/local/bin/redis-ebpf-monitor.bt"
    echo ""
    echo "  3ï¸âƒ£  Check hardware performance counters:"
    echo "     $ redis-perf-stat.sh 30"
    echo ""
    echo "  4ï¸âƒ£  ðŸ†• Analyze branch prediction:"
    echo "     $ redis-branch-profile.sh 30"
    echo ""
    echo "  5ï¸âƒ£  Monitor real-time performance:"
    echo "     $ redis-monitor-advanced.sh"
    echo ""
    echo "  6ï¸âƒ£  Verify latency:"
    echo "     $ redis-cli --latency-history"
    echo ""
    echo "  7ï¸âƒ£  Check slow queries:"
    echo "     $ redis-cli SLOWLOG GET 10"
    echo ""
    echo "  8ï¸âƒ£  Memory analysis:"
    echo "     $ redis-memcheck.sh"
    echo ""
    echo "  9ï¸âƒ£  Read full documentation:"
    echo "     $ less /etc/redis/PERFORMANCE_TUNING.md"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "âš ï¸  IMPORTANT NOTES:"
    echo ""
    echo "  â€¢ These optimizations prioritize PERFORMANCE over everything"
    echo "  â€¢ Some security features may be relaxed"
    echo "  â€¢ Test thoroughly before production use"
    echo "  â€¢ Monitor system closely for first few hours"
    echo "  â€¢ Backup configurations are saved with .backup extension"
    echo ""
    if [ "$CPU_CORES" -gt 4 ]; then
    echo "  ðŸ’Ž CPU Isolation: Reboot required for FULL effect"
    echo "    Add to GRUB: isolcpus=0,1 nohz_full=0,1 rcu_nocbs=0,1"
    echo "    Edit: /etc/default/grub â†’ GRUB_CMDLINE_LINUX"
    echo "    Run: update-grub && reboot"
    fi
    echo ""
    echo "  ðŸ”¥ ULTRA Optimizations Applied:"
    echo "    âœ“ CPU Realtime Pinning (cores 0-1 shielded)"
    echo "    âœ“ SIMD Vectorization (AVX/AVX2/AVX512)"
    echo "    âœ“ Branch Prediction Profiling"
    echo "    âœ“ Memory Prefetching (kernel-level)"
    echo "    âœ“ NUMA Memory Binding (intelligent)"
    echo "    âœ“ Kernel Bypass Networking (busy polling)"
    echo "    âœ“ TCP Zero-Copy (sendfile/splice)"
    echo "    âœ“ Lock-Free Algorithms (futex optimized)"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    log_success "ðŸš€ðŸ’¥ðŸ’Ž REDIS IS NOW ULTRA-INSANELY OPTIMIZED! ðŸ’ŽðŸ’¥ðŸš€"
    echo ""
    log_success "Expected ULTRA Performance:"
    echo "  â€¢ Latency p50: < 100 microseconds"
    echo "  â€¢ Latency p99: < 300 microseconds"
    echo "  â€¢ Latency p99.9: < 500 microseconds"
    echo "  â€¢ Throughput: > 200K ops/sec (single instance)"
    echo "  â€¢ Memory Efficiency: < 1.15 fragmentation"
    echo "  â€¢ CPU Efficiency: < 3% for 100K ops/sec"
    echo "  â€¢ Branch Miss Rate: < 1%"
    echo "  â€¢ Cache Miss Rate: < 2%"
    echo ""
    
    pause
}

###############################################################################
# UTILITY MENU FUNCTIONS
###############################################################################

check_redis_status() {
    log_section "TRáº NG THÃI REDIS"
    
    echo ""
    
    if ! command -v redis-cli &> /dev/null; then
        log_error "Redis chÆ°a Ä‘Æ°á»£c cÃ i Ä‘áº·t"
        pause
        return
    fi
    
    log_info "Redis Version:"
    redis-server --version
    
    echo ""
    log_info "Service Status:"
    systemctl status redis.service --no-pager
    
    echo ""
    log_info "Redis Info:"
    redis-cli INFO server | grep -E "redis_version|redis_mode|os|arch_bits|process_id|uptime_in_days"
    
    echo ""
    log_info "Memory Info:"
    redis-cli INFO memory | grep -E "used_memory_human|used_memory_peak_human|maxmemory_human"
    
    echo ""
    log_info "Stats:"
    redis-cli INFO stats | grep -E "total_connections_received|total_commands_processed|instantaneous_ops_per_sec|keyspace_hits|keyspace_misses"
    
    pause
}

run_redis_benchmark() {
    log_section "BENCHMARK REDIS"
    
    if ! check_redis_installed; then
        return
    fi
    
    echo ""
    log_info "Äang cháº¡y benchmark vá»›i 100,000 requests..."
    echo ""
    
    redis-benchmark -q -n 100000 -c 50 -P 10
    
    echo ""
    log_info "Kiá»ƒm tra latency..."
    redis-cli --latency-history -i 1 | head -10
    
    pause
}

view_redis_logs() {
    log_section "LOGS REDIS"
    
    if [ ! -f /var/log/redis/redis-server.log ]; then
        log_error "Log file khÃ´ng tá»“n táº¡i"
        pause
        return
    fi
    
    echo ""
    echo "10 dÃ²ng log cuá»‘i cÃ¹ng:"
    echo ""
    
    tail -20 /var/log/redis/redis-server.log
    
    echo ""
    read -p "Xem toÃ n bá»™ log? (y/n): " view_all
    
    if [[ "$view_all" == "y" || "$view_all" == "Y" ]]; then
        less /var/log/redis/redis-server.log
    fi
    
    pause
}

backup_redis_data() {
    log_section "BACKUP REDIS"
    
    if ! check_redis_installed; then
        return
    fi
    
    if [ -f /usr/local/bin/redis-backup.sh ]; then
        /usr/local/bin/redis-backup.sh
    else
        BACKUP_DIR="/var/backups/redis"
        DATE=$(date +%Y%m%d_%H%M%S)
        
        mkdir -p "$BACKUP_DIR"
        
        log_info "Táº¡o backup..."
        redis-cli BGSAVE
        sleep 3
        
        if [ -f /var/lib/redis/dump.rdb ]; then
            cp /var/lib/redis/dump.rdb "$BACKUP_DIR/dump_${DATE}.rdb"
            log_success "Backup thÃ nh cÃ´ng: $BACKUP_DIR/dump_${DATE}.rdb"
        else
            log_error "KhÃ´ng tÃ¬m tháº¥y file dump.rdb"
        fi
    fi
    
    pause
}

show_tips() {
    log_section "Máº¸O & HÆ¯á»šNG DáºªN"
    
    cat <<'EOF'

ðŸ“Œ CÃC Lá»†NH Há»®U ÃCH:

1. Káº¿t ná»‘i Redis:
   redis-cli
   redis-cli ping

2. Kiá»ƒm tra thÃ´ng tin:
   redis-cli INFO
   redis-cli INFO memory
   redis-cli INFO stats

3. Quáº£n lÃ½ service:
   sudo systemctl status redis
   sudo systemctl restart redis
   sudo systemctl stop redis
   sudo systemctl start redis

4. Xem logs:
   sudo tail -f /var/log/redis/redis-server.log
   sudo journalctl -u redis -f

5. Monitoring:
   redis-cli MONITOR
   redis-cli --latency
   redis-cli --stat

6. Backup:
   redis-cli BGSAVE
   redis-cli SAVE

7. Slow queries:
   redis-cli SLOWLOG GET 10
   redis-cli SLOWLOG LEN

ðŸ“Œ FILE QUAN TRá»ŒNG:

   - Config: /etc/redis/redis.conf
   - Data: /var/lib/redis/
   - Logs: /var/log/redis/
   - Service: /etc/systemd/system/redis.service

ðŸ“Œ Tá»I Æ¯U HIá»†U SUáº¤T:

   1. Sá»­ dá»¥ng Pipeline cho multiple commands
   2. DÃ¹ng Hashes thay vÃ¬ nhiá»u keys
   3. Set maxmemory phÃ¹ há»£p vá»›i RAM
   4. Chá»n maxmemory-policy Ä‘Ãºng:
      - allkeys-lru: Cache
      - volatile-lru: Session
      - noeviction: Queue
   5. Báº­t AOF cho data persistence
   6. Monitor slow queries thÆ°á»ng xuyÃªn

ðŸ“Œ Báº¢O Máº¬T:

   1. Äáº·t password máº¡nh:
      requirepass your_strong_password

   2. Bind Ä‘Ãºng interface:
      bind 127.0.0.1  # Local only
      bind 0.0.0.0    # All (cáº§n password!)

   3. Rename commands nguy hiá»ƒm:
      rename-command FLUSHALL ""
      rename-command CONFIG "my_secret_config"

   4. Sá»­ dá»¥ng firewall:
      sudo ufw allow from trusted_ip to any port 6379

EOF

    pause
}

###############################################################################
# MAIN MENU
###############################################################################

show_header() {
    clear
    echo -e "${CYAN}"
    cat <<'EOF'
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                            â•‘
â•‘              ðŸš€ REDIS MANAGER - ALL-IN-ONE ðŸš€              â•‘
â•‘                                                            â•‘
â•‘         CÃ i Ä‘áº·t, Gá»¡ cÃ i Ä‘áº·t & SiÃªu Tá»‘i Æ°u hÃ³a Redis       â•‘
â•‘                    Cho Ubuntu 20.04+                       â•‘
â•‘                                                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
}

show_menu() {
    echo ""
    echo -e "${GREEN}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    echo -e "${GREEN}â”‚            MENU CHÃNH                   â”‚${NC}"
    echo -e "${GREEN}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
    echo -e "${GREEN}â”‚                                         â”‚${NC}"
    echo -e "${GREEN}â”‚  ${YELLOW}1${NC}. CÃ i Ä‘áº·t Redis                    ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚  ${YELLOW}2${NC}. Gá»¡ cÃ i Ä‘áº·t Redis                 ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚  ${YELLOW}3${NC}. SiÃªu tá»‘i Æ°u hÃ³a Redis            ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚                                         â”‚${NC}"
    echo -e "${GREEN}â”‚  ${CYAN}4${NC}. Kiá»ƒm tra tráº¡ng thÃ¡i               ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚  ${CYAN}5${NC}. Cháº¡y Benchmark                    ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚  ${CYAN}6${NC}. Xem Logs                          ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚  ${CYAN}7${NC}. Backup dá»¯ liá»‡u                    ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚  ${CYAN}8${NC}. Máº¹o & HÆ°á»›ng dáº«n                   ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚                                         â”‚${NC}"
    echo -e "${GREEN}â”‚  ${RED}0${NC}. ThoÃ¡t                             ${GREEN}â”‚${NC}"
    echo -e "${GREEN}â”‚                                         â”‚${NC}"
    echo -e "${GREEN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
    echo ""
    
    # Show system info
    if command -v redis-cli &> /dev/null && systemctl is-active --quiet redis.service; then
        echo -e "${BLUE}[â€¢]${NC} Redis Ä‘ang cháº¡y | RAM: ${TOTAL_RAM_GB}GB | CPU: ${CPU_CORES} cores"
    else
        echo -e "${YELLOW}[â€¢]${NC} Redis chÆ°a cÃ i Ä‘áº·t hoáº·c khÃ´ng cháº¡y"
    fi
    
    echo ""
}

main_menu() {
    while true; do
        show_header
        show_menu
        
        read -p "Chá»n chá»©c nÄƒng [0-8]: " choice
        
        case $choice in
            1)
                install_redis_complete
                ;;
            2)
                uninstall_redis_complete
                ;;
            3)
                optimize_redis_complete
                ;;
            4)
                check_redis_status
                ;;
            5)
                run_redis_benchmark
                ;;
            6)
                view_redis_logs
                ;;
            7)
                backup_redis_data
                ;;
            8)
                show_tips
                ;;
            0)
                echo ""
                log_info "Cáº£m Æ¡n báº¡n Ä‘Ã£ sá»­ dá»¥ng Redis Manager!"
                echo ""
                exit 0
                ;;
            *)
                log_error "Lá»±a chá»n khÃ´ng há»£p lá»‡!"
                sleep 1
                ;;
        esac
    done
}

###############################################################################
# MAIN EXECUTION
###############################################################################

# Check if running as root for main operations
if [[ "$1" != "--help" && "$1" != "-h" ]]; then
    check_root
fi

# Handle command line arguments
case "$1" in
    --help|-h)
        echo "Redis Manager - All-in-One Script"
        echo ""
        echo "Sá»­ dá»¥ng: sudo $0 [option]"
        echo ""
        echo "Options:"
        echo "  (khÃ´ng option)  Hiá»ƒn thá»‹ menu tÆ°Æ¡ng tÃ¡c"
        echo "  --help, -h      Hiá»ƒn thá»‹ help nÃ y"
        echo ""
        exit 0
        ;;
    *)
        detect_system
        main_menu
        ;;
esac
