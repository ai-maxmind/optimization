#!/bin/bash
# modules/net/net-irq-pinning.sh
# Module: IRQ affinity management for NIC queues
# Pin network interrupts to specific CPUs for better performance

MOD_ID="net.irq-pinning"
MOD_DESC="NIC IRQ affinity"
MOD_STAGE="net"
MOD_RISK="high"
MOD_DEFAULT_ENABLED="false"

mod_id() {
    echo "$MOD_ID"
}

mod_can_run() {
    # Check if we have network interfaces
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    if [[ -z "$ifaces" ]]; then
        ultra_log_debug "No network interfaces found"
        return 1
    fi
    
    # Check for multi-queue NIC (multiple interrupts per interface)
    local has_multi_queue=0
    for iface in $ifaces; do
        local irq_count=$(grep -c "$iface" /proc/interrupts 2>/dev/null || echo 0)
        if [[ $irq_count -gt 1 ]]; then
            has_multi_queue=1
            break
        fi
    done
    
    if [[ $has_multi_queue -eq 0 ]]; then
        ultra_log_debug "No multi-queue NICs detected"
        return 1
    fi
    
    # Get CPU count
    local cpu_count=$(nproc)
    if [[ $cpu_count -lt 4 ]]; then
        ultra_log_debug "Not enough CPUs for IRQ pinning (need 4+)"
        return 1
    fi
    
    return 0
}

mod_apply() {
    ultra_log_module_start "$MOD_ID"
    ultra_log_info "Applying NIC IRQ affinity optimization..."
    
    local profile=$(ultra_get_profile)
    local cpu_count=$(nproc)
    
    # IRQ affinity strategy:
    # - Spread NIC IRQs across different CPUs
    # - Avoid CPU 0 (usually handles other system IRQs)
    # - Use NUMA-local CPUs if possible
    # - Reserve some CPUs for application threads
    
    ultra_log_info "System info:"
    ultra_log_info "  Total CPUs: $cpu_count"
    
    # Determine IRQ pinning strategy
    local pin_strategy="spread"
    local reserve_cpus=1
    
    case "$profile" in
        server)
            # Spread IRQs evenly
            pin_strategy="spread"
            reserve_cpus=1
            ;;
        db)
            # Reserve more CPUs for database threads
            pin_strategy="spread"
            reserve_cpus=2
            ;;
        lowlatency)
            # Pin IRQs to specific CPUs, isolate others
            pin_strategy="dedicated"
            reserve_cpus=2
            ;;
        desktop)
            # Balanced approach
            pin_strategy="spread"
            reserve_cpus=1
            ;;
        *)
            pin_strategy="spread"
            reserve_cpus=1
            ;;
    esac
    
    ultra_log_info "  Pin strategy: $pin_strategy"
    ultra_log_info "  Reserved CPUs: $reserve_cpus (CPU 0 + $((reserve_cpus-1)) others)"
    
    # Get list of network interfaces
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    
    ultra_log_info ""
    ultra_log_info "Network interfaces: $ifaces"
    
    if ultra_is_dry_run; then
        ultra_log_info "[DRY-RUN] Would configure IRQ affinity"
        ultra_state_finalize_module "$MOD_ID" "success"
        ultra_log_module_end "$MOD_ID"
        return 0
    fi
    
    # Create systemd service
    local service_dir="/etc/systemd/system"
    local service_file="$service_dir/ultra-net-irq-pinning.service"
    local script_file="/usr/local/bin/ultra-net-irq-pinning.sh"
    
    # Backup existing files
    [[ -f "$service_file" ]] && ultra_backup_file "$service_file" "$MOD_ID"
    [[ -f "$script_file" ]] && ultra_backup_file "$script_file" "$MOD_ID"
    
    # Create IRQ pinning script
    cat > "$script_file" <<'EOF'
#!/bin/bash
# Generated by Ubuntu Ultra Optimizer - net.irq-pinning
# Pin network IRQs to specific CPUs

CPU_COUNT=$(nproc)
RESERVE_CPUS=__RESERVE_CPUS__
STRATEGY="__STRATEGY__"

# CPUs available for IRQ pinning (skip CPU 0 and reserved)
START_CPU=$RESERVE_CPUS
AVAIL_CPUS=$((CPU_COUNT - RESERVE_CPUS))

if [[ $AVAIL_CPUS -lt 1 ]]; then
    echo "Not enough CPUs for IRQ pinning"
    exit 1
fi

# Get network interface IRQs
get_net_irqs() {
    local iface="$1"
    grep "$iface" /proc/interrupts | awk -F: '{print $1}' | tr -d ' '
}

# Set IRQ affinity to a specific CPU
set_irq_affinity() {
    local irq="$1"
    local cpu="$2"
    
    if [[ ! -f /proc/irq/$irq/smp_affinity_list ]]; then
        return 1
    fi
    
    # Set CPU affinity
    echo "$cpu" > /proc/irq/$irq/smp_affinity_list 2>/dev/null || true
    echo "IRQ $irq -> CPU $cpu"
}

# Pin IRQs for an interface
pin_interface_irqs() {
    local iface="$1"
    local irqs=$(get_net_irqs "$iface")
    
    if [[ -z "$irqs" ]]; then
        echo "No IRQs found for $iface"
        return 1
    fi
    
    echo "Pinning IRQs for $iface: $irqs"
    
    local cpu=$START_CPU
    local irq_count=0
    
    for irq in $irqs; do
        if [[ "$STRATEGY" == "spread" ]]; then
            # Spread IRQs across available CPUs
            local target_cpu=$((START_CPU + (irq_count % AVAIL_CPUS)))
            set_irq_affinity "$irq" "$target_cpu"
        elif [[ "$STRATEGY" == "dedicated" ]]; then
            # Dedicate CPUs to IRQs
            local target_cpu=$((START_CPU + irq_count))
            if [[ $target_cpu -lt $CPU_COUNT ]]; then
                set_irq_affinity "$irq" "$target_cpu"
            fi
        fi
        
        irq_count=$((irq_count + 1))
    done
}

# Disable irqbalance (conflicts with manual pinning)
if systemctl is-active irqbalance &>/dev/null; then
    echo "Stopping irqbalance (conflicts with manual IRQ pinning)"
    systemctl stop irqbalance
    systemctl disable irqbalance
fi

# Apply to all network interfaces
IFACES="__IFACES__"
for iface in $IFACES; do
    pin_interface_irqs "$iface"
done
EOF
    
    # Substitute variables
    sed -i "s/__RESERVE_CPUS__/$reserve_cpus/" "$script_file"
    sed -i "s/__STRATEGY__/$pin_strategy/" "$script_file"
    sed -i "s/__IFACES__/$ifaces/" "$script_file"
    
    chmod +x "$script_file"
    ultra_log_info "✅ Created: $script_file"
    
    # Create systemd service
    cat > "$service_file" <<EOF
[Unit]
Description=Ubuntu Ultra Optimizer - Network IRQ Pinning
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=$script_file
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    
    ultra_log_info "✅ Created: $service_file"
    
    # Enable and start service
    systemctl daemon-reload
    systemctl enable ultra-net-irq-pinning.service &>/dev/null
    systemctl start ultra-net-irq-pinning.service &>/dev/null
    
    ultra_state_add_action "$MOD_ID" "network" "Configured IRQ pinning for: $ifaces"
    ultra_log_info "✅ IRQ pinning applied"
    
    ultra_log_info ""
    ultra_log_info "Important notes:"
    ultra_log_info "  - irqbalance service has been disabled (conflicts)"
    ultra_log_info "  - Check IRQ affinity: cat /proc/irq/*/smp_affinity_list"
    ultra_log_info "  - Monitor IRQ distribution: watch -n1 'cat /proc/interrupts | grep eth'"
    ultra_log_info "  - Use 'mpstat -P ALL 1' to see per-CPU interrupt load"
    ultra_log_info "  - Combine with CPU isolation for best low-latency results"
    
    ultra_state_finalize_module "$MOD_ID" "success"
    ultra_log_module_end "$MOD_ID"
}

mod_rollback() {
    local run_id="$1"
    
    ultra_log_info "Rolling back $MOD_DESC..."
    
    # Stop and disable service
    systemctl stop ultra-net-irq-pinning.service &>/dev/null
    systemctl disable ultra-net-irq-pinning.service &>/dev/null
    
    # Remove files
    rm -f /etc/systemd/system/ultra-net-irq-pinning.service
    rm -f /usr/local/bin/ultra-net-irq-pinning.sh
    
    systemctl daemon-reload
    
    # Re-enable irqbalance
    if command -v irqbalance &>/dev/null; then
        systemctl enable irqbalance &>/dev/null
        systemctl start irqbalance &>/dev/null
        ultra_log_info "Re-enabled irqbalance"
    fi
    
    ultra_log_info "Rollback complete"
}

mod_verify() {
    ultra_log_info "IRQ Affinity Configuration:"
    
    if [[ -f /etc/systemd/system/ultra-net-irq-pinning.service ]]; then
        ultra_log_info "✅ Service exists"
        
        if systemctl is-active ultra-net-irq-pinning.service &>/dev/null; then
            ultra_log_info "✅ Service is active"
        else
            ultra_log_warn "❌ Service is not active"
        fi
    else
        ultra_log_warn "❌ Service not found"
    fi
    
    ultra_log_info ""
    ultra_log_info "irqbalance status:"
    if systemctl is-active irqbalance &>/dev/null; then
        ultra_log_warn "⚠️  irqbalance is running (may conflict)"
    else
        ultra_log_info "✅ irqbalance is disabled"
    fi
    
    ultra_log_info ""
    ultra_log_info "Network IRQ distribution:"
    
    # Show IRQs for network interfaces
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    for iface in $ifaces; do
        ultra_log_info ""
        ultra_log_info "Interface: $iface"
        
        local irqs=$(grep "$iface" /proc/interrupts | awk -F: '{print $1}' | tr -d ' ')
        for irq in $irqs; do
            if [[ -f /proc/irq/$irq/smp_affinity_list ]]; then
                local cpu=$(cat /proc/irq/$irq/smp_affinity_list)
                echo "  IRQ $irq -> CPU $cpu"
            fi
        done
    done
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "This module should be run through the orchestrator"
    exit 1
fi
