#!/bin/bash
# modules/net/net-rps-rfs.sh
# Module: RPS/RFS configuration
# Receive Packet Steering and Receive Flow Steering for better packet distribution

MOD_ID="net.rps-rfs"
MOD_DESC="RPS/RFS packet steering"
MOD_STAGE="net"
MOD_RISK="medium"
MOD_DEFAULT_ENABLED="true"

mod_id() {
    echo "$MOD_ID"
}

mod_can_run() {
    # Check if we have network interfaces
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    if [[ -z "$ifaces" ]]; then
        ultra_log_debug "No network interfaces found"
        return 1
    fi
    
    # Check if RPS is supported
    local test_iface=$(echo "$ifaces" | head -1)
    if [[ ! -d /sys/class/net/$test_iface/queues ]]; then
        ultra_log_debug "RPS/RFS not supported"
        return 1
    fi
    
    local cpu_count=$(nproc)
    if [[ $cpu_count -lt 2 ]]; then
        ultra_log_debug "Need 2+ CPUs for RPS/RFS"
        return 1
    fi
    
    return 0
}

mod_apply() {
    ultra_log_module_start "$MOD_ID"
    ultra_log_info "Applying RPS/RFS optimization..."
    
    local profile=$(ultra_get_profile)
    local cpu_count=$(nproc)
    
    # RPS (Receive Packet Steering):
    # Distributes RX packet processing across multiple CPUs
    # Useful for single-queue NICs or when hardware queues < CPU count
    
    # RFS (Receive Flow Steering):
    # Directs packets to CPU where application is running
    # Improves cache locality
    
    # Calculate RPS mask (all CPUs except CPU 0)
    local rps_mask=""
    if [[ $cpu_count -le 4 ]]; then
        # Small systems: use all CPUs
        rps_mask="ff"  # Binary: 11111111 (CPUs 0-7)
    elif [[ $cpu_count -le 8 ]]; then
        rps_mask="fe"  # Binary: 11111110 (CPUs 1-7, skip CPU 0)
    elif [[ $cpu_count -le 16 ]]; then
        rps_mask="fffe"  # CPUs 1-15
    elif [[ $cpu_count -le 32 ]]; then
        rps_mask="fffffffe"  # CPUs 1-31
    else
        rps_mask="fffffffe"  # CPUs 1-31 (32 cores sufficient)
    fi
    
    # RFS entries (flow table size)
    local rfs_entries=32768
    case "$profile" in
        server)
            rfs_entries=32768
            ;;
        db)
            rfs_entries=32768
            ;;
        lowlatency)
            rfs_entries=65536
            ;;
        desktop)
            rfs_entries=16384
            ;;
        *)
            rfs_entries=32768
            ;;
    esac
    
    ultra_log_info "RPS/RFS configuration:"
    ultra_log_info "  Total CPUs: $cpu_count"
    ultra_log_info "  RPS CPU mask: 0x$rps_mask"
    ultra_log_info "  RFS entries: $rfs_entries"
    
    # Get network interfaces
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    ultra_log_info "  Network interfaces: $ifaces"
    
    if ultra_is_dry_run; then
        ultra_log_info "[DRY-RUN] Would configure RPS/RFS"
        ultra_state_finalize_module "$MOD_ID" "success"
        ultra_log_module_end "$MOD_ID"
        return 0
    fi
    
    # Global RFS setting
    if [[ -f /proc/sys/net/core/rps_sock_flow_entries ]]; then
        echo "$rfs_entries" > /proc/sys/net/core/rps_sock_flow_entries
        ultra_apply_sysctl "net.core.rps_sock_flow_entries" "$rfs_entries" "$MOD_ID"
    fi
    
    # Create systemd service
    local service_dir="/etc/systemd/system"
    local service_file="$service_dir/ultra-net-rps-rfs.service"
    local script_file="/usr/local/bin/ultra-net-rps-rfs.sh"
    
    [[ -f "$service_file" ]] && ultra_backup_file "$service_file" "$MOD_ID"
    [[ -f "$script_file" ]] && ultra_backup_file "$script_file" "$MOD_ID"
    
    # Create RPS/RFS configuration script
    cat > "$script_file" <<EOF
#!/bin/bash
# Generated by Ubuntu Ultra Optimizer - $MOD_ID
# Configure RPS/RFS for network interfaces

RPS_MASK="$rps_mask"
RFS_ENTRIES="$rfs_entries"

configure_interface() {
    local iface="\$1"
    
    # Check if interface exists
    if [[ ! -d /sys/class/net/\$iface ]]; then
        return 1
    fi
    
    echo "Configuring RPS/RFS for \$iface"
    
    # Configure RPS for each RX queue
    for rx_queue in /sys/class/net/\$iface/queues/rx-*; do
        if [[ -d "\$rx_queue" ]]; then
            # Set RPS CPU mask
            echo "\$RPS_MASK" > "\$rx_queue/rps_cpus" 2>/dev/null || true
            
            # Set RFS flow entries per queue
            echo "\$RFS_ENTRIES" > "\$rx_queue/rps_flow_cnt" 2>/dev/null || true
            
            echo "  \$(basename \$rx_queue): rps_cpus=\$RPS_MASK, rps_flow_cnt=\$RFS_ENTRIES"
        fi
    done
}

# Apply to all interfaces
IFACES="$ifaces"
for iface in \$IFACES; do
    configure_interface "\$iface"
done

# Set global RFS entries
if [[ -f /proc/sys/net/core/rps_sock_flow_entries ]]; then
    echo "\$RFS_ENTRIES" > /proc/sys/net/core/rps_sock_flow_entries
    echo "Global rps_sock_flow_entries=\$RFS_ENTRIES"
fi
EOF
    
    chmod +x "$script_file"
    ultra_log_info "✅ Created: $script_file"
    
    # Create systemd service
    cat > "$service_file" <<EOF
[Unit]
Description=Ubuntu Ultra Optimizer - RPS/RFS Configuration
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=$script_file
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    
    ultra_log_info "✅ Created: $service_file"
    
    # Enable and start service
    systemctl daemon-reload
    systemctl enable ultra-net-rps-rfs.service &>/dev/null
    systemctl start ultra-net-rps-rfs.service &>/dev/null
    
    ultra_state_add_action "$MOD_ID" "network" "Configured RPS/RFS for: $ifaces"
    ultra_log_info "✅ RPS/RFS configured"
    
    ultra_log_info ""
    ultra_log_info "RPS/RFS benefits:"
    ultra_log_info "  - Better packet distribution across CPUs"
    ultra_log_info "  - Improved cache locality with RFS"
    ultra_log_info "  - Especially useful for single-queue NICs"
    ultra_log_info "  - Can improve throughput by 20-40% on multi-core"
    
    ultra_log_info ""
    ultra_log_info "Monitoring:"
    ultra_log_info "  cat /sys/class/net/<iface>/queues/rx-0/rps_cpus"
    ultra_log_info "  cat /proc/net/softnet_stat  # Check CPU RX stats"
    ultra_log_info "  mpstat -P ALL 1             # Monitor per-CPU usage"
    
    ultra_state_finalize_module "$MOD_ID" "success"
    ultra_log_module_end "$MOD_ID"
}

mod_rollback() {
    local run_id="$1"
    
    ultra_log_info "Rolling back $MOD_DESC..."
    
    # Stop and disable service
    systemctl stop ultra-net-rps-rfs.service &>/dev/null
    systemctl disable ultra-net-rps-rfs.service &>/dev/null
    
    # Remove files
    rm -f /etc/systemd/system/ultra-net-rps-rfs.service
    rm -f /usr/local/bin/ultra-net-rps-rfs.sh
    
    systemctl daemon-reload
    
    # Reset RPS/RFS to defaults (0 = disabled)
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    for iface in $ifaces; do
        for rx_queue in /sys/class/net/$iface/queues/rx-*; do
            if [[ -d "$rx_queue" ]]; then
                echo "0" > "$rx_queue/rps_cpus" 2>/dev/null || true
                echo "0" > "$rx_queue/rps_flow_cnt" 2>/dev/null || true
            fi
        done
    done
    
    ultra_rollback_sysctl "net.core.rps_sock_flow_entries" "$MOD_ID" "$run_id"
    ultra_log_info "Rollback complete"
}

mod_verify() {
    ultra_log_info "RPS/RFS Configuration:"
    
    if [[ -f /etc/systemd/system/ultra-net-rps-rfs.service ]]; then
        ultra_log_info "✅ Service exists"
        
        if systemctl is-active ultra-net-rps-rfs.service &>/dev/null; then
            ultra_log_info "✅ Service is active"
        else
            ultra_log_warn "❌ Service is not active"
        fi
    else
        ultra_log_warn "❌ Service not found"
    fi
    
    ultra_log_info ""
    ultra_log_info "Global RFS entries:"
    if [[ -f /proc/sys/net/core/rps_sock_flow_entries ]]; then
        local entries=$(cat /proc/sys/net/core/rps_sock_flow_entries)
        ultra_log_info "  rps_sock_flow_entries: $entries"
    fi
    
    ultra_log_info ""
    ultra_log_info "Per-interface RPS/RFS:"
    
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    for iface in $ifaces; do
        ultra_log_info ""
        ultra_log_info "Interface: $iface"
        
        for rx_queue in /sys/class/net/$iface/queues/rx-*; do
            if [[ -d "$rx_queue" ]]; then
                local rps_cpus=$(cat "$rx_queue/rps_cpus" 2>/dev/null || echo "0")
                local rps_flow=$(cat "$rx_queue/rps_flow_cnt" 2>/dev/null || echo "0")
                echo "  $(basename $rx_queue): cpus=0x$rps_cpus, flow_cnt=$rps_flow"
            fi
        done
    done
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "This module should be run through the orchestrator"
    exit 1
fi
