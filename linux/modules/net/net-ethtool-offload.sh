#!/bin/bash
# modules/net/net-ethtool-offload.sh
# Module: Network hardware offload features
# Enables/disables NIC offload features for performance

MOD_ID="net.ethtool-offload"
MOD_DESC="Network hardware offload"
MOD_STAGE="net"
MOD_RISK="medium"
MOD_DEFAULT_ENABLED="true"

mod_id() {
    echo "$MOD_ID"
}

mod_can_run() {
    # Check if ethtool is available
    if ! command -v ethtool &>/dev/null; then
        ultra_log_debug "ethtool not found"
        return 1
    fi
    
    # Check if we have network interfaces
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    if [[ -z "$ifaces" ]]; then
        ultra_log_debug "No network interfaces found"
        return 1
    fi
    
    return 0
}

mod_apply() {
    ultra_log_module_start "$MOD_ID"
    ultra_log_info "Applying network hardware offload optimization..."
    
    local profile=$(ultra_get_profile)
    
    # Network offload features:
    # TSO (TCP Segmentation Offload): NIC handles TCP segmentation
    # GSO (Generic Segmentation Offload): Software alternative to TSO
    # GRO (Generic Receive Offload): Aggregate packets before passing to stack
    # LRO (Large Receive Offload): Hardware packet aggregation
    # rx/tx checksumming: NIC calculates checksums
    # scatter-gather: Efficient DMA for fragmented packets
    
    local enable_tso="on"
    local enable_gso="on"
    local enable_gro="on"
    local enable_lro="off"  # LRO can break routing, use GRO instead
    local enable_rx_csum="on"
    local enable_tx_csum="on"
    local enable_sg="on"
    
    case "$profile" in
        server|db)
            # High throughput server
            enable_tso="on"
            enable_gso="on"
            enable_gro="on"
            enable_lro="off"
            enable_rx_csum="on"
            enable_tx_csum="on"
            enable_sg="on"
            ;;
        lowlatency)
            # Low latency: disable some offloads to reduce processing delay
            enable_tso="off"
            enable_gso="off"
            enable_gro="off"
            enable_lro="off"
            enable_rx_csum="on"
            enable_tx_csum="on"
            enable_sg="on"
            ;;
        desktop)
            # Desktop: balanced
            enable_tso="on"
            enable_gso="on"
            enable_gro="on"
            enable_lro="off"
            enable_rx_csum="on"
            enable_tx_csum="on"
            enable_sg="on"
            ;;
        *)
            # Default: all on except LRO
            enable_tso="on"
            enable_gso="on"
            enable_gro="on"
            enable_lro="off"
            enable_rx_csum="on"
            enable_tx_csum="on"
            enable_sg="on"
            ;;
    esac
    
    ultra_log_info "Offload configuration (profile: $profile):"
    ultra_log_info "  TSO (TCP Segmentation Offload): $enable_tso"
    ultra_log_info "  GSO (Generic Segmentation Offload): $enable_gso"
    ultra_log_info "  GRO (Generic Receive Offload): $enable_gro"
    ultra_log_info "  LRO (Large Receive Offload): $enable_lro (usually off)"
    ultra_log_info "  RX Checksum: $enable_rx_csum"
    ultra_log_info "  TX Checksum: $enable_tx_csum"
    ultra_log_info "  Scatter-Gather: $enable_sg"
    
    # Get list of network interfaces (exclude loopback)
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    
    ultra_log_info ""
    ultra_log_info "Network interfaces: $ifaces"
    
    if ultra_is_dry_run; then
        ultra_log_info "[DRY-RUN] Would configure offload features"
        ultra_state_finalize_module "$MOD_ID" "success"
        ultra_log_module_end "$MOD_ID"
        return 0
    fi
    
    # Create systemd service to apply on boot
    local service_dir="/etc/systemd/system"
    local service_file="$service_dir/ultra-net-offload.service"
    local script_file="/usr/local/bin/ultra-net-offload.sh"
    
    # Backup existing files
    [[ -f "$service_file" ]] && ultra_backup_file "$service_file" "$MOD_ID"
    [[ -f "$script_file" ]] && ultra_backup_file "$script_file" "$MOD_ID"
    
    # Create offload script
    cat > "$script_file" <<EOF
#!/bin/bash
# Generated by Ubuntu Ultra Optimizer - $MOD_ID
# Apply network offload settings

apply_offload() {
    local iface="\$1"
    
    # Check if interface exists and is up
    if ! ip link show "\$iface" &>/dev/null; then
        return 1
    fi
    
    # Apply offload settings (ignore errors for unsupported features)
    ethtool -K "\$iface" tso $enable_tso 2>/dev/null || true
    ethtool -K "\$iface" gso $enable_gso 2>/dev/null || true
    ethtool -K "\$iface" gro $enable_gro 2>/dev/null || true
    ethtool -K "\$iface" lro $enable_lro 2>/dev/null || true
    ethtool -K "\$iface" rx $enable_rx_csum 2>/dev/null || true
    ethtool -K "\$iface" tx $enable_tx_csum 2>/dev/null || true
    ethtool -K "\$iface" sg $enable_sg 2>/dev/null || true
    
    echo "Applied offload settings to \$iface"
}

# Apply to all non-loopback interfaces
for iface in $ifaces; do
    apply_offload "\$iface"
done
EOF
    
    chmod +x "$script_file"
    ultra_log_info "✅ Created: $script_file"
    
    # Create systemd service
    cat > "$service_file" <<EOF
[Unit]
Description=Ubuntu Ultra Optimizer - Network Offload
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=$script_file
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    
    ultra_log_info "✅ Created: $service_file"
    
    # Enable and start service
    systemctl daemon-reload
    systemctl enable ultra-net-offload.service &>/dev/null
    systemctl start ultra-net-offload.service &>/dev/null
    
    ultra_state_add_action "$MOD_ID" "network" "Configured offload for: $ifaces"
    ultra_log_info "✅ Offload settings applied"
    
    ultra_log_info ""
    ultra_log_info "Note:"
    ultra_log_info "  - Some NICs may not support all features"
    ultra_log_info "  - Use 'ethtool -k <iface>' to check current settings"
    ultra_log_info "  - For low-latency, offloads are disabled to reduce CPU delay"
    ultra_log_info "  - LRO is disabled (can break routing), use GRO instead"
    
    ultra_state_finalize_module "$MOD_ID" "success"
    ultra_log_module_end "$MOD_ID"
}

mod_rollback() {
    local run_id="$1"
    
    ultra_log_info "Rolling back $MOD_DESC..."
    
    # Stop and disable service
    systemctl stop ultra-net-offload.service &>/dev/null
    systemctl disable ultra-net-offload.service &>/dev/null
    
    # Remove files
    rm -f /etc/systemd/system/ultra-net-offload.service
    rm -f /usr/local/bin/ultra-net-offload.sh
    
    systemctl daemon-reload
    
    ultra_log_info "Rollback complete"
    ultra_log_info "Note: Offload settings reset to NIC defaults"
}

mod_verify() {
    ultra_log_info "Network Offload Configuration:"
    
    if [[ -f /etc/systemd/system/ultra-net-offload.service ]]; then
        ultra_log_info "✅ Service exists"
        
        if systemctl is-active ultra-net-offload.service &>/dev/null; then
            ultra_log_info "✅ Service is active"
        else
            ultra_log_warn "❌ Service is not active"
        fi
    else
        ultra_log_warn "❌ Service not found"
    fi
    
    ultra_log_info ""
    ultra_log_info "Current offload settings:"
    
    # Show offload for each interface
    local ifaces=$(ip link show | grep -E '^[0-9]+: ' | grep -v 'lo:' | awk -F': ' '{print $2}')
    for iface in $ifaces; do
        ultra_log_info ""
        ultra_log_info "Interface: $iface"
        
        if command -v ethtool &>/dev/null; then
            ethtool -k "$iface" 2>/dev/null | grep -E 'tcp-segmentation-offload|generic-segmentation-offload|generic-receive-offload|large-receive-offload|rx-checksumming|tx-checksumming|scatter-gather' | head -7
        fi
    done
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "This module should be run through the orchestrator"
    exit 1
fi
