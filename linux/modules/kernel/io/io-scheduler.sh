#!/bin/bash
################################################################################
# MODULE: kernel.io.io-scheduler
# Configure I/O scheduler based on storage type
################################################################################

MOD_ID="kernel.io.io-scheduler"
MOD_DESC="Configure optimal I/O scheduler for each storage device"
MOD_STAGE="kernel-io"
MOD_RISK="low"
MOD_DEFAULT_ENABLED="true"

mod_id() {
    echo "$MOD_ID"
}

mod_can_run() {
    # Check if any block devices exist
    local devices=$(ultra_hw_storage_get_devices)
    if [[ -z "$devices" ]]; then
        ultra_log_warn "No block devices found"
        return 1
    fi
    return 0
}

mod_apply() {
    ultra_log_info "Applying $MOD_DESC"
    
    local udev_rules_file="/etc/udev/rules.d/60-ultra-opt-io-scheduler.rules"
    
    # Backup if exists
    if [[ -f "$udev_rules_file" ]] && ! ultra_should_skip_backup; then
        ultra_backup_file "$udev_rules_file" "$MOD_ID"
    fi
    
    # Create udev rules
    if ! ultra_is_dry_run; then
        echo "# Generated by Ubuntu Ultra Optimizer - I/O Scheduler Rules" > "$udev_rules_file"
        echo "# Module: $MOD_ID" >> "$udev_rules_file"
        echo "# Generated: $(date -Iseconds)" >> "$udev_rules_file"
        echo "" >> "$udev_rules_file"
    fi
    
    # Process each storage device
    for device in $(ultra_hw_storage_get_devices); do
        local device_type=$(ultra_hw_storage_get_type "$device")
        local optimal_scheduler=""
        local read_ahead_kb=256
        local nr_requests=1024
        local rq_affinity=2
        
        # Determine optimal scheduler
        case "$device_type" in
            nvme)
                optimal_scheduler="none"
                read_ahead_kb=256
                nr_requests=1024
                ;;
            ssd)
                # Modern SSDs with multi-queue
                if [[ -d "/sys/block/$device/mq" ]]; then
                    optimal_scheduler="none"  # Multi-queue blk-mq
                else
                    optimal_scheduler="noop"   # Legacy single-queue
                fi
                read_ahead_kb=256
                nr_requests=1024
                ;;
            hdd)
                # Rotational: need deadline or mq-deadline
                if [[ -d "/sys/block/$device/mq" ]]; then
                    optimal_scheduler="mq-deadline"
                else
                    optimal_scheduler="deadline"
                fi
                read_ahead_kb=512
                nr_requests=256
                ;;
            *)
                ultra_log_warn "Unknown device type for $device"
                continue
                ;;
        esac
        
        ultra_log_info "Device $device ($device_type): scheduler=$optimal_scheduler, read_ahead=$read_ahead_kb KB"
        
        # Save current settings
        if [[ -f "/sys/block/$device/queue/scheduler" ]]; then
            local current_sched=$(cat "/sys/block/$device/queue/scheduler" | grep -oP '\[\K[^\]]+')
            ultra_state_save_module_before "$MOD_ID" "scheduler:$device" "$current_sched"
        fi
        
        # Apply immediately (runtime)
        if ! ultra_is_dry_run; then
            # Set scheduler
            if [[ -f "/sys/block/$device/queue/scheduler" ]]; then
                if grep -q "$optimal_scheduler" "/sys/block/$device/queue/scheduler"; then
                    echo "$optimal_scheduler" > "/sys/block/$device/queue/scheduler" 2>/dev/null || true
                fi
            fi
            
            # Set read-ahead
            if [[ -f "/sys/block/$device/queue/read_ahead_kb" ]]; then
                echo "$read_ahead_kb" > "/sys/block/$device/queue/read_ahead_kb"
            fi
            
            # Set queue depth
            if [[ -f "/sys/block/$device/queue/nr_requests" ]]; then
                echo "$nr_requests" > "/sys/block/$device/queue/nr_requests"
            fi
            
            # Set rq_affinity (2 = complete on same CPU)
            if [[ -f "/sys/block/$device/queue/rq_affinity" ]]; then
                echo "$rq_affinity" > "/sys/block/$device/queue/rq_affinity"
            fi
            
            # Disable add_random (RNG entropy from I/O)
            if [[ -f "/sys/block/$device/queue/add_random" ]]; then
                echo "0" > "/sys/block/$device/queue/add_random"
            fi
            
            # Disable iostats if not needed (reduces overhead)
            if [[ -f "/sys/block/$device/queue/iostats" ]]; then
                echo "0" > "/sys/block/$device/queue/iostats"
            fi
        else
            ultra_log_dry_run "Set $device: scheduler=$optimal_scheduler, read_ahead=$read_ahead_kb"
        fi
        
        # Add udev rule for persistence
        if ! ultra_is_dry_run; then
            cat >> "$udev_rules_file" << EOF
# Device: $device (type: $device_type)
ACTION=="add|change", KERNEL=="$device", ATTR{queue/scheduler}="$optimal_scheduler", \\
    ATTR{queue/read_ahead_kb}="$read_ahead_kb", \\
    ATTR{queue/nr_requests}="$nr_requests", \\
    ATTR{queue/rq_affinity}="$rq_affinity", \\
    ATTR{queue/add_random}="0", \\
    ATTR{queue/iostats}="0"

EOF
        fi
        
        ultra_state_save_module_after "$MOD_ID" "scheduler:$device" "$optimal_scheduler"
        ultra_state_add_action "$MOD_ID" "udev" "Configured I/O scheduler for $device: $optimal_scheduler"
    done
    
    # Reload udev rules
    if ! ultra_is_dry_run; then
        udevadm control --reload-rules
        udevadm trigger --subsystem-match=block
        ultra_log_info "Reloaded udev rules for I/O scheduler persistence"
    fi
    
    # Global I/O tuning
    ultra_sysctl_save_and_set "vm.dirty_ratio" "10" "$MOD_ID"
    ultra_sysctl_save_and_set "vm.dirty_background_ratio" "5" "$MOD_ID"
}

mod_rollback() {
    ultra_log_info "Rolling back $MOD_ID"
    
    local run_id="$1"
    local state_file="$ULTRA_STATE_DIR/$run_id/${MOD_ID}.json"
    
    # Remove udev rules
    local udev_rules_file="/etc/udev/rules.d/60-ultra-opt-io-scheduler.rules"
    if [[ -f "$udev_rules_file" ]]; then
        rm -f "$udev_rules_file"
        udevadm control --reload-rules
        udevadm trigger --subsystem-match=block
        ultra_log_info "Removed I/O scheduler udev rules"
    fi
    
    # Restore original schedulers (runtime only)
    if [[ -f "$state_file" ]] && command -v jq &>/dev/null; then
        for device in $(ultra_hw_storage_get_devices); do
            local sched_before=$(jq -r ".before[\"scheduler:$device\"]" "$state_file")
            if [[ "$sched_before" != "null" ]] && [[ -n "$sched_before" ]]; then
                if [[ -f "/sys/block/$device/queue/scheduler" ]]; then
                    echo "$sched_before" > "/sys/block/$device/queue/scheduler" 2>/dev/null || true
                    ultra_log_info "Restored scheduler for $device: $sched_before"
                fi
            fi
        done
    fi
}

mod_verify() {
    ultra_log_info "Current I/O scheduler configuration:"
    
    for device in $(ultra_hw_storage_get_devices); do
        if [[ -f "/sys/block/$device/queue/scheduler" ]]; then
            local sched=$(cat "/sys/block/$device/queue/scheduler")
            local read_ahead=$(cat "/sys/block/$device/queue/read_ahead_kb")
            local nr_req=$(cat "/sys/block/$device/queue/nr_requests")
            ultra_log_info "  $device: $sched (read_ahead: ${read_ahead}KB, queue: $nr_req)"
        fi
    done
}
